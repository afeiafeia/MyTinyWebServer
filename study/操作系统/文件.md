内核使用三种数据结构表示文件：
1. 每个进程的控制块中有一个文件描述符表，每个进程打开的文件占用一项，每一项记录了文件描述符标志和一个指向文件表项的指针
2. 内核为所有进程打开的所有文件维护了一张文件表，
   每一项包含：
             文件状态标志（读、写、同步、阻塞、非阻塞）
             当前文件的偏移量；
             指向文件i节点表项的指针
3. 每个文件有一个i节点，其内包含的文件的具体信息，它是在打开文件的时候从磁盘读取到内存的（inode是打开相应文件时加载到内存）



## open函数
```c++
int open(const char* path,int flag,.../*mode_t mode*/)



```


## 文件系统的页高速缓存如何实现？
参考：《现代操作系统》
内存的读写速度要远大于磁盘的读写速度，所以对于文件的读写，一般是为其在内存中分配若干页面，称为页高速缓存，它们在逻辑上属于磁盘；
对于一个文件，当打开时，进程中创建一个文件描述符表项，它指向内核文件表中的一个文件表项，
文件表项指向i节点数据（当打开一个文件时，该文件的i节点被加载到内存，内核slab分配器分配一个inode对象存储此文件的i节点数据）；
如果在打开文件时没有指定O_DIRECT选项（指定改选项表示文件使用直接IO，不使用高速缓存），如果没有指定，则在内存中会分配高速缓存
当访问一个文件时，由文件描述符得到文件描述符表项，再得到文件表项，再访问其i节点，得到磁盘块地址，然后通过内核中对于高速缓存管理的数据结构访问对应的磁盘块，例如通过哈希表管理，通过对磁盘地址哈希得到相应的高速缓存块；
需要注意的是：文件的高速缓存区域大小并不是与文件大小一致，应该是对每个文件，都是固定大小，需要读不在缓存中的内容时，就从磁盘加载到缓存，再从缓存读；而整个缓存区域大小应该也是固定的，当用完时，通过页面换入换出的方式进行换入换出；


但是对于大文件，使用也告诉缓存反而会降低效率，因为大文件会占据高速缓存，导致热点的小文件无法利用缓存，对于这些小文件，读写性能就会降低
另一方面，因为大文件没能利用局部性原理，缓存进来的数据基本不会再回头访问，当值对于大文件的访问每次都要先访问高速缓存，然后因为无法找到数据再去访问磁盘，导致访问效率降低

大文件传输的解决方案：
使用异步IO，异步IO不会使用页缓存


              