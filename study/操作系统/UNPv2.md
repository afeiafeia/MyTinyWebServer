# 共享内存区
## 定义
* 共享内存区是最快的进程间同步的方式，使用共享内存区，进程间的数据传递就不需要再通过内核，但要注意的是：在往共享内存区读取、写入数据时，要进行同步；
进行间同步时，用来同步的锁、条件变量也要在共享内存区中创建；

* 共享内存区是随内核持续的IPC:一直存在，直到重启或者显式删除该共享内存区

* fork之后，父进程的共享内存区也存在于子进程，但子进程调用exec后，会去除共享内存区


## 实现
共享内存区通过mmap来实现，unmmap来删除

mmap的使用目的：mmap用来创建一块虚拟内存区域
> * 程序加载时，通过可执行文件的文件头为进程创建虚拟内存区域
> * 程序运行期间，使用普通文件以提供文件映射IO 
> * 使用特殊文件以提供匿名内存映射
> * 使用shm_open以提供任意进程间的共享内存区

```c
void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);
//start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址

//length：映射区的长度

//prot：期望的内存保护标志，不能与文件的打开模式冲突
//PROT_READ 表示页内容可以被读取

//flags：指定映射对象的类型，映射选项和映射页是否可以共享
//MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件

//fd：有效的文件描述符，一般是由open()函数返回

//off_toffset：被映射对象内容的起点
```

任意进程间共享内存区的创建，两种方案：
1. 每个进程使用open打开一个相同的文件，然后调用mmap映射到自己的虚拟地址空间，这样，每个进程的这一块虚拟地址空间都与该文件的物理内存建立了映射关系，而物理内存只有一份，所以每个进程对该文件的写，都可以共享到其它进程；
2. 使用Posix共享内存区对象，该对象由shm_open打开，然后同样使用mmap将shm_open返回的文件描述符映射到调用进程的虚拟地址空间

## mmap函数的用法：*UNPv2 12.2节*
1. 使用普通文件提供文件映射IO
2. 使用特殊文件提供匿名映射IO，当创建共享内存区的使用，如果使用普通文件，则必须指定一个所用进程都知道的文件，使用时，先创建或者打开该文件，然后将该文件映射到每个进程的虚拟地址空间，而BSD提供匿名映射，彻底避免了文件的创建和打开，办法是：将flags参数指定为MAP_SHARED|MAP_ANON，把fd参数指定为-1，这样可以直接创建一个内存区域，其内容初始化为0
```c
int main(int arggc,char** argv)
{
    int* ptr = nullptr;
    ptr = mmap(NULL,sizeof(int),PORT_READ|PORT_WRITE,MAP_SHARED|MAP_ANON,-1,0);
}

```

3. 使用共享内存区对象创建进程间共享的共享内存区




## FIFO与共享内存区

相同点：都可以用于进程间通信

不同点：
（1）
FIFO是半双工的，只能打开来读或者打开来写，不能既读又写（UNPv2 P42）
共享内存区可以实现既读又写
（2）
FIFO存在于内核，因此进程间通信时需要陷入内核；而共享内存区处于用户态，不需要陷入内核

（3）当写入的数据量小于管道容量时，写入操作是原子的，不需要同步，但当写入数据量大于容量时，需要同步（UNPv2 P46）
而对于共享内存区，读写要同步

（4）写入管道的是字节流，没有边界（*消息队列不是字节流，而是结构化的消息，每个消息有一个长度和优先级，因此它是有边界的*）
