操作系统所提供的所有IO函数都是围绕文件描述符的，当使用open打开一个文件时，返回一个文件描述符，然后这个文件描述符用于后续的IO操作；
而流是标准IO库操作的对象，标准IO库是一个函数库，它操作的对象是流，通过对流而非文件描述符的操作来进行IO;
流对象是一个结构，它包含了标准IO库进行IO所需要的所有信息，包括用于IO的文件描述符、指向流缓冲区的指针、缓冲区的长度、当前在缓冲区的字符数以及出错标志
流负责操作缓冲区;*流缓冲区是在用户空间而不是内核，流按照全缓冲、行缓冲、不缓冲的方式调用文件IO的函数将缓冲区的数据写入内核，因此从这一点来看，流缓冲区是不在内核的*
*全缓冲：每次调用IO系统调用时，往内核高速缓存中写的数据时流缓冲区中的所有数据*
*行缓冲：每次调用IO系统调用时，往内核高速缓存中写的数据时流缓冲区中的一行*
*不缓冲：每当通过fputs或者其他写入函数往流中写数据时，都会调用一次write，将这些数据（不管有没有换行）写入内核里面的高速缓存*

提供缓冲区的目的是：减少对read、write的系统调用,它是将信息从设备传入给进程或者从进程传输给设备的临时存储区域
例如：
``` c++
char buff[255];
fgets(buff,stdin);
```
将终端输入（键盘输入）的字符传递给进程中的变量buff：会先将数据存入stdin的缓冲区，然后从缓存区取出传递给buff



同一个成员的尺寸大小可能随着编译程序和系统的不同而不同（内存对齐在不同系统上是不一样的）；   
用来存储多字节整数和浮点值的二进制格式在不同系统上也可能会不同；     
以上的原因，使得在不同系统间交换二进制数据的实际解决方法是使用互认的规范格式（网络协议）

fgets与fputs
二者是行缓冲的读写，fgets从流中读取一行，
```c++
char* fgets(char* buff,int size,FILE* fp)
//从流fp的缓冲区中读取最多size-1字节的数据到buff所指的区域，读到换行符'\n'为止，注意不是读到'\0'！！！
//如果读了size-1个数据后还没有读到换行，则停止读取，在最后放入'\0'，此时读到的是一个不完整的行
```

* fputs将数据放入缓冲区：它是将一个以'\0'结尾的字符串写到流的缓冲区中，注意它不是读到换行符'\n'终止，而是读到'\0'终止
  因此，放入流缓冲区的数据可能是多行，但是从流缓冲区往磁盘或者终端写时，是按照一行数据调用一次write来进行的

## cout与printf的区别、endl与换行符'\n'的区别：     
cout是标准输出流，它具有一个缓冲区，它在输出的时候会刷新缓冲区，而printf是没有缓冲区的，因此，cout的输出相对要慢一些；
endl是一个操作符，它不仅仅实现了换行的操作，而且对缓冲区进行了刷新（对于每一个流，都管理着一个缓冲）     
<https://blog.csdn.net/ysayk/article/details/50959909>
<https://www.cnblogs.com/wangzhiyi/p/9491969.html>


## read、write并不是对磁盘上数据的IO，而是对磁盘上数据对应的内核中的高速缓存进行IO，因此write之后，数据并不会立即更新到磁盘里面，此时write之后如果断电，还是可能丢失数据的！！！
<https://www.cnblogs.com/JohnABC/p/5821660.html>
<https://blog.csdn.net/qq_25327609/article/details/83660992?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-9.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-9.no_search_link>

##　刷新缓冲区的时机：
1. 缓冲区满
2. 执行flush
3. 执行endl
4. 关闭文件(显式调用close或者程序退出自动关闭文件)