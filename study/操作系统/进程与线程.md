## fork 
Linux的fork使用写时拷贝技术,延迟甚至可能避免对父进程资源的拷贝，子进程共享父进程的虚拟地址空间、打开的文件描述符、文件系统信息、信号以及信号处理函数等，只复制父进程的页表；    
写时拷贝技术推迟甚至避免了对父进程信息的拷贝，使得进程的创建很快

## vfork   
fork与vfork都是通过clone()系统调用来实现的，只是传递给clone的参数不同，这些参数决定了父子进程共享哪些信息；

相比fork,vfork还使得子进程与父进程共享页表，另外，fork之后，父子进程都可以继续运行，但vfork后，父进程将阻塞，直到子进程退出或者调用exec函数，另外，子进程不能向这个共享的地址空间执行写入操作；


## 进程控制块（或者进程描述符）
现代操作系统（p419）   
记录了进程相关的所有信息，是内核管理进程所需要的重要信息；主要有以下一些内容：
（1）调度参数：进程优先级、最近消耗的CPU时间、最近睡眠的时间（例如如果睡眠太久，就提高进程优先级防止进程饿死），内核据此进行进程的调度；    
（2）虚拟内存区域：记录进程的每个虚拟内存区域（例如代码段、数据段、堆、栈）的信息；   
（3）页表指针：指向页表（页表在内核内存中）；
（4）内核栈指针  
（5）信号：掩码显示了哪些信号被忽略、哪些信号需要捕捉、哪些被阻塞以及哪些正在传递，另外记录需要捕捉的信号的信号处理函数；   
（6）机器寄存器：上下文切换时保存、恢复寄存器信息；   
（7）系统调用状态：记录“当前”系统调用的信息:像参数和返回值；   
（8）文件描述符表：记录进程打开的文件，其中每一表项中记录文件句柄（文件描述符）以及相应的文件表项的指针，文件表项是内核维护的表，记录了所有进程打开的所有文件的信息，例如文件状态标志（以可读或者可写或者可读可写等方式打开的文件）、当前文件的偏移量、i节点指针（指向i节点表项，记录了文件的物理信息 *（详看UNIX环境高级编程3.10节）*）   
（9）统计数据：指向用户（多用户系统，此时不能仅仅按照进程调度，要考虑每个用户不能长时间占用CPU资源）或者进程占用系统CPU的时间，
（10）其它:PID、PPID以及当前目录、根目录等


## 进程调度算法
1. 先来先服务调度：每次从就绪队列中取队列头部也就是最先进入就绪队列的进程调度运行
2. 最短作业优先调度：优先选择运行时间最短的进程来运行，可能造成长作业的饿死现象
3. 高响应比优先调度：通过等待时间加上服务时间，再除以服务时间，得到一个响应比，调度时选择响应比最高的就绪进程运行，这样的话，对于长作业，随着等待时间延长，响应比会提高，从而得到运行，避免饿死现象
4. 时间片轮转调度：每个进程分配一个时间片，时间片用完后，如果进程没有结束或者阻塞，强行换出，调度下一个就绪进程运行
5. 最高优先级调度：每个进程被赋予一个优先级，调度时，调度优先级最高的就绪进程，优先级可以在进程创建的时候赋予，也可以根据运行状态调整
6. 多级反馈队列调度： 维护多个队列，每个队列一个优先级，优先级由高至低，每当进程就绪时，放入最高优先级的队列中，当进程运行耗完时间片还没有结束时，将其放入低一级的队列中，长时间等待的就绪进程会提高优先级，放入更高的队列，每次从最高的非空队列中取就绪进程运行

## 子进程终止(Unix环境高级编程，10.7节)
*僵死进程：*进程在终止的时候，会释放CPU以及运行相关的资源例如虚拟内存区域（mm_struct）、页表、递减文件描述符、文件系统的引用次数，如果减为0就关闭它们，但进程的描述符(task_struct)以及内核栈、thread_info仍然存在，此时进程处于*僵死状态*，   在释放资源后，子进程会向父进程发送一个SIG_CHLD信号，当从此信号处理函数退出后，子进程会完全释放所有资源，但是如果父进程没有捕捉该信号或者没有显式忽略（该信号的默认动作也是忽略，但是隐式与显式不同），则子进程剩余资源将一直无法释放，一直存在于系统中，直至系统退出（关机）
*僵死状态的作用：* 它的作用是向父进程提供信息；在上述终结的过程中，一方面会为子进程重新寻找养父，可能是线程组中的线程或者Init进程，另一方面，会向父进程发送一个SIG_CHLD信号，以供父进行获取子进程的信息（例如PID、消耗CPU的时间等），当从该信号处理函数返回后，子进程才真正终结，释放掉所有资源；
*孤儿进程*：如果父进程在子进程终止之前退出，子进程就是孤儿进程，孤儿进程将被Init进程收养，最终由Init进程对他们完成状态收集工作；
<https://www.cnblogs.com/Anker/p/3271773.html>
父进程可以忽略该信号或者捕捉该信号进行信息的获取，但要注意的是！！！：虽然对于该信号，默认动作就是忽略，但是如果采用默认行为，子进程会一直处于僵死状态，然后到父进程终结时为其寻找养父Init，最终由Init释放清除；因此如果要忽略该信号，应该**显式**地忽略：
``` signal(SIG_CHLD,SIG_IGN)```   
<https://blog.csdn.net/lmh12506/article/details/6679992?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.essearch_pc_relevant>


## 为什么有了进行还需要线程？
1. 进程在同一时间只能做一件事
2. 进程在执行过程中如果因为某些原因（例如IO）阻塞，整个进行都将挂起，其它与IO无关的工作也停止；

引入线程的原因：
除了解决上面的两个问题，还有：
3. 对并发实体共享地址空间的需要；
4. 线程更容易创建和销毁
5. 存在大量计算、大量IO的进程中，采用多线程可以提高并发程度



## 进程与线程共享的内容：
1. 进程处理栈区之外的其他地址空间
2. 进行打开的文件描述符
3. 进程的信号处理函数（信号呢？、锁呢？）
4. 进程的当前目录
5. 进程ID和进程组ID


##　线程独有的内容
1. 线程ID：线程的唯一标识符
2. 机器寄存器（寄存器的值）：线程切换时，保存切换前寄存器的值，以便切换回来时恢复现场
3. 线程对堆栈：每个线程有自己的栈区，
4. error：error虽然作为进程的全局变量，但是并不为进程的线程所共享，因为进程中一般存在多个线程，因为可能一个线程设置了error值后被调度出去，还没有处理error，另一个线程再设置error为另一值，切换回来后，error值就不正确了
多线程库中（c++thread），线程使用TLS（线程局部存储），每个线程独有一份
实现原理：当定义一个线程局部存储变量时，会放在.tls段中，每当创建一个线程，就会在进行的堆中申请一块内存来存储该线程局部变量<https://blog.csdn.net/weixin_30681121/article/details/98080056>
5. 优先级
6. 信号屏蔽码（APUE）   


## 线程的终止(APUE 11.5节)
线程可以直接调用exit退出，但这样会导致整个进程退出，如果只是要终止某个线程而不影响其它线程和进程，有以下三种方式：
1. 直接返回
2. 被同一个进程中的其他线程取消
3. 调用pthread_exit退出



线程相关函数：
（1）pthread_exit:  *void pthrea_exit(void *ptr);*
ptr是线程的返回值

（2）pthread_join: *int pthread_join(pthread_t threadId,void * * ptr);*：
*调用此函数的线程将一直阻塞，直到指定的线程threadId调用pthread_exit、或者直接返回或者被取消*，如果是直接返回，ptr中存放的是返回值，如果线程被取消，ptr指向的内存单元被设置为PTHREAD_CANCELED

（3）pthread_cancel:*int pthread_cancel(pthread_t threadId)*
线程调用pthread_cancel来取消同一个进程中id为threadId的线程，默认情况下，调用线程会取消threadId的线程，但threadId可以忽略这个取消，使得不被其他线程取消

（4）pthread_detach:*int pthread_detach(pthread_t threadId)*
将线程从调用线程分离出去，调用线程不会等待threadId线程退出，当线程threadId终止时，立刻回收线程对资源，如果对一个线程threadId调用的pthread_detach，就不能再调用pthread_join

线程池
同步

## 协程
<https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952>
协程是一种用户态的线程，协程的上下文切换和调度是在用户态实现的;协程分为对称协程和非对称协程；
对称协程是协程的调用通过调度器来指向，协程通过yield退出后，将cpu控制权讲给调度器，调度器决定调度哪一个协程继续运行；
非对称协程的调度则是通过调度器或者其它协程来实现；一个协程可以通过resume调度另一个协程运行，一个协程通过yield退出后，cpu控制权返回给调度该协程的那个协程


## 线程的同步
在生产者消费者模型中，如果使用互斥锁和条件变量来实现同步，当生产者或者消费者需要wait时，为什么使用循环而不是条件判断？
```c++
pthread_mutex_lock();
while(...)
{
    pthread_cond_wait();

}
```

父子进行是否共享IPC？*Unpv2 1.5节*
1. 匿名管道（pipe）和命名管道（fifo）：fork之后，因为子进程共享父进程所有打开的文件描述符，所以共享；但是当子进程执行exec后，如果父进程最初打开文件时指定了FD_CLOEXEC,则会在子进程关闭共享的文件描述符
2. 消息队列：fork之后，父子进程共享，当子进程执行exec后，子进程中将关闭这些消息队列描述符
3. 互斥锁、条件变量：fork后如果它们处于共享内存区并且具有进程间共享属性，则继续共享，否则不共享；
4. 信号量：fork之后，父子进程共享，子进程exec后，不再共享
5. 共享内存区：fork之后，父子进程共享，子进程执行exec后，去除