<https://www.cnblogs.com/wxquare/p/4699429.html>

## 为什么需要迭代器?
STL将容器和算法分离，再通过迭代器将二者联系起来
使用迭代器可以实现泛型编程，为每一种容器都定义迭代器，都有自增、自减、解引用、调用这些操作，只是容器之间这些内部实现不同，这样，一个泛型函数可以通过迭代器对不同容器进行访问



## 在TinySTL项目中
(1)为什么迭代器要分成普通迭代器和常量迭代器？
以容器的begin()、end()函数为例，分别返回第一个迭代器和最后一个迭代器的下一位置，如果调用函数的容器是常量，需要保证返回的迭代器不能用来修改迭代器所指的元素；
显然，如果只有普通迭代器，无法满足此要求，将迭代器看做指针，常量迭代器相当于底层const指针，即不能通过指针（迭代器修改所指的元素）

因此，常量迭代器的解引用运算符（*）返回常量引用，调用运算符（->）返回常量指针（底层const指针）
而一般迭代器返回普通引用和普通指针
可以定义一个基类，解引用运算符和调用运算符分别在两个派生类（普通迭代器和常量迭代器）中重写

(2)迭代器与节点的指针有什么区别？与节点内数据的指针有什么区别？
1. 一般情况下，迭代器是对节点指针的封装，相比于一个节点指针，它实现了迭代器的重通用接口的具体实现，例如自增、自减，解引用、调用，以供标准库函数使用；
2. 节点指针与节点中数据的指针的区别：节点数据和相邻节点的额外指针共同构成一个节点，这些额外的指针用来组织起整个数据结构；
需要注意的是：*在迭代器解引用或者调用时，应该操作的是迭代器中的节点指针所指向的节点中数据的指针*
```c++


reference operator*()
{
    return node->value;
}


pointer operator&()
{
    return &(*operator());//注意返回的是节点中数据的地址（作为指针进行后续操作（例如调用数据的函数））
}
```