作者：敲代码的神射手
链接：https://www.nowcoder.com/discuss/738827?type=2&channel=-1&source_id=discuss_terminal_discuss_hot_nctrack
来源：牛客网

1. 析构函数为什么要设为虚函数？（无法释放子类对象 内存泄露）
   * 如果基类指针或者引用指向派生类对象，通过指针或者引用释放对象，动态绑定到子类的析构函数，否则调用基类构造函数，子类对象得不到完全释放，出现内存泄露

2. 虚函数是如何实现的（虚函数指针 虚函数表那一套）
   * 还有虚函数的类，编译器会为其生成一个虚函数表指针成员变量，所有的虚函数放在一个虚函数表中，虚函数表指针指向这个表，调用虚函数时，会通过指针在表中找到对应的虚函数

3. 菱形继承，虚继承
4. C++一个空类占多少字节（C++空类的大小不为0，不同编译器设置不一样，vs设置为1） 
    一个空类默认有哪几个函数（我说6个...说着说着最后俩给忘了.....）
   * 空类占用一个字节；
   * （1）默认构造函数、*但编译器并不总是可以生成一个默认构造函数，如果一个类中含有一个其它类类型的成员，而且该成员所属的类没有默认构造函数，则编译器不会合成默认构造函数*
   * （2）左值引用形式的拷贝构造函数、
   * （3）右值引用形式的拷贝构造函数
   * （4）左值引用形式拷贝赋值运算符、
   * （5）右值引用形式的拷贝赋值运算符
   * （6）析构函数，
   *  *new 和delete???应该也有？？？*

5. 动态链接 静态链接
   静态链接：将调用的函数所在的目标文件拷贝到可执行文件（链接是以目标文件为单位*自我修养p123*），成为可执行文件的一部分；这种链接方式不需要依赖库，可执行文件可以独立执行，但是如果静态库更新，程序需要重新链接，另外就是无法共享代码
   静态库：目标文件打包压缩形成，可以理解为一组目标文件的集合

   动态链接：链接时不拷贝库中的函数，只记录函数名可参数以及函数所在文件等信息，
6. 对象池了解吗？（不了解）







STL 标准模板库
1. 平时用哪些容器啊（vector list unordered_map stack .....）
2. vector和List区别
   vector是连续地址空间，数据逻辑连续、物理连续
   list的数据时逻辑连续，物理上地址不连续
3. 说一下小顶堆（堆排序），大致分为几个步骤
创建堆、插入、删除

## 设计模式
1. 了解哪些设计模式
2. 单例模式用过是吧，那说一下单例模式如何实现（private构造 静态指针 静态方法）
   * 构造函数私有
   * 静态指针，指向该类对象的唯一实例
   * 静态函数，回去指向唯一对象的静态指针
3. 单例模式双检查锁
   ```c++
   if(m_sSingleTon == nullptr)
   {
       lock();
       if(m_sSingleTon == nullptr)
       {

       }
   }
   ```

4. 是双检查 还是双锁？（？？啥意思？）
    后面又扯了一下双检查锁的reorder现象 解决方法 volatile
    * 双检查
    * 虽然是双重检查，但是编译器可能会改变指令的顺序，例如可能将锁放在前面，双检查放在后面；使用volatile可以阻止编译器改变指令的顺序

## 操作系统
1. 进程间通信 （六大金刚）
   * 匿名管道（Pipe）、命名管道、锁、信号量、条件变量、共享内存区、远程调用

2. 线程同步与互斥 重点问了一下锁（互斥锁 读写锁 自旋锁 条件锁）
   * 互斥锁
     指互斥使用的锁，用来保护临界区，保证任何时刻只有一个线程或者进程可以得到该锁进行临界区的访问，访问临界区之前，进程或者线程需要先获取锁，
     如果此时有其他进程或者线程已经获得了该锁，就会被阻塞，直到锁被其他线程或进程释放，保证上锁和解锁时间内，临界区只能被一个进程或者线程访问；

   * 条件锁
     用于等待，通过pthread_cond_wait可以直接让调用线程或者进程阻塞，直到调用pthread_cond_signal将等待在该条件锁上的线程或者进程唤醒
     条件锁总是和互斥锁配合使用，等待的时候也是要指定等待在哪个锁上，条件锁的唤醒有两种方式，一是signal，它唤醒等待在该信号锁上的其中一个线程或者进程，而是broadcast,它唤醒等待在该锁上的所有线程进程
     对于互斥锁、条件变量，如果是静态分配的（全局变量、静态变量），使用宏PTHREAD_XXX_INITIALIZER初始化，它用于线程间同步，如果要实现进程间同步，需要分配在共享内存区，初始化使用pthread_mutex_init()进行，如果是动态分配，也使用函数而不是宏初始化锁（*静态分配得到一个对象，动态分配或者分配在共享内存区，得到的都是指针*）

   * 读写锁
     线程对于共享数据的操作一般有读和写，有时候需要将这两种操作区分，对于读操作而言，并不会改变数据，多个进程可以同时进行，但对于写操作，需要整个写操作完成后，其他线程才可以再次读或者写
     因此需要跟进读写状态进行加锁；
     读写锁的规则是：
     只要没有线程进行获得该锁进行写操作，其它线程都可以获得锁然后进行读
     只有没有其他线程获得锁进行读或者写时，当前线程才可以获得锁进行写
     也尝试过用互斥锁和条件变量以及一些记录读写者数量的变量来实现读写锁：条件变量此时相当于锁，通过条件变量来是线程阻塞，数量变量用来判断何时进入阻塞，互斥锁用来互斥访问数量变量


3. 无锁队列了解吗？如何实现的
    （CAS原子操作）
    使用CAS原子操作，CAS读取一个值，比较它与原始值是否相同，如果是，则将其替换为期望值，否则什么都不做
    <https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653192625&idx=1&sn=cbabbd806e4874e8793332724ca9d454&chksm=8c99f36bbbee7a7d169581dedbe09658d0b0edb62d2cbc9ba4c40f706cb678c7d8c768afb666&mpshare=1&scene=23&srcid=0922FgFSaCHnCGuWPOJIcmSA&sharer_sharetime=1569140904106&sharer_shareid=2018cf6405c5abd5c9ca4109a0beb1c2#rd>

    <https://coolshell.cn/articles/8239.html>
    <https://blog.csdn.net/linyt/article/details/5764312>
    <https://zhuanlan.zhihu.com/p/136208506>
    <https://www.cnblogs.com/myd620/p/7114843.html>
4. CAS如何实现的 （原本值 期望值 更新值，C++11 atomic类）
计算机网络
1. 四次挥手 每一次结束之后的状态位
   以服务器先断开连接为例：
   （1）服务器向客户端发送一个FIN分节，进入FIN_WAIT1状态，客户端收到FIN后，回复一个ACK进入CLOSE_WAIT状态，
   （2）然后客户端关闭连接，向服务器端发送一个FIN分节，自己进入LAST_WAIT状态；
   （3）服务器收到自己发送到FIN的ACK后，进入FIN_WAIT2状态；
   （4）收到客户端发送到FIN分节后，回复一个ACK并进入TIME_WAIT状态，
   （5）客户端收到ACK后，断开
   （6）服务器端TIME_WAIT状态持续2MSL后断开
   


2. timewait状态 为什么需要两个最大报文寿命
   有两个目的：
   （1）确保第二个FIN分节得到确认，如果FIN分节的ACK在传输过程中丢失，2倍的MSL可以保证重新发送FIN分节并得到确认（如果不再出现丢包的问题）
   （2）使旧的报文在下一次连接建立前消逝，如果网路中出现环路，导致某个包陷入循环，之后该包被重传正确到达对端，如果连接是立即断开，且在两个主机的相同端口又建立的TCP连接，且此时网络得到修复，陷入循环的包被发送出去，这时就会发送给新连接，2MSL可以保证在下次连接时，当前连接在网络中运输的包都已经消逝


LINUX
1. 查看CPU状态（top）
2. 查看进程
3. 查看磁盘文件（du df）
4. IO多路复用 （select poll epoll）
    select 和epoll区别 
    具体回答了一下 select用户态内核态两次拷贝 以及两次遍历
    epoll 如何通过红黑树+链表+回调机制处理socket的
数据库（答得不好）
1. 如果一个SQL语句 查询效率很慢如何定位？
（我以为要问怎么办？（索引），结果说是如何定位？？回答不知道）
* 通过慢查询日志定位zaf
1. 数据库优化（分库分表 读写分离）
2. 主从分离如何保证数据一致性？
3. 联合索引遵循什么原则？（我说了一个最左匹配原则....好像不是他想要的答案...有会的老哥教教我）