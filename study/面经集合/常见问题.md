## 线程是不是越多越好？一般设置几个？
线程并不是越多越好，线程是为了实现并发，但并发程序必须要考虑上下文切换的问题，即，线程切换导致的系统开销，多线程在IO密集型线程中才有意义，因为在IO阻塞期间，CPU可以切换到其他线程进行处理，而对于CPU密集型线程，均是在占用CPU进行计算，使用多线程反而会增加上下文切换时的开销，但即使对于IO密集型程序，也不应该使用过多的工作线程，否则线程间的切换将占用大量的CPU时间，用于处理业务逻辑的CPU时间所占比重就少了，也正因此，为每个连接创建一个线程并不可取，线程池中，一般是一个线程处理多个连接；（*linux高性能服务器编程8.7.3节*）

另外，线程是操作系统的资源，操作系统对线程对总数量有限制，如果一个进程创建的太多线程，可能会影响其它多线程进程

对于N核的主机，设单线程计算时间x，等待时间y，则线程数设置为N*(x+y)/x可以让CPU利用率最大化，对于CPU密集型程序，设置线程数与CPU内核一致

## 单核CPU设置多线程有意义吗？
1. 多线程可以让代码逻辑更清晰；
2. 可后期移植到多核CPU上；
3. 对于CPU密集型程序，设置多核没有意义，反而增加上下文切换的开销
4. 对于IO密集型程序，则是有意义的，一个线程阻塞在IO上时，可以切换到其他线程运行，提高性能

## cookie和session的区别：
http协议是无状态的，不记录用户的信息，使用cookie或者session是为了标识用户、记录用户的信息、活动状态等
1. cookie是将数据存储在客户端，存储方式有两种：存储在本地磁盘或者存放在浏览器进程中，这种保存在客户端的方式不安全
2. session将数据保存在服务器内存中；
3. 在打开的页面中第一次访问服务器时，服务器端分配内存记录当前这个会话的信息，并生成一个SessionID用来标识这个会话，SessionID作为cookie存放在客户端浏览器内存中，后面继续访问该服务器时，请求报文的首部会附上SessionId，服务器以此根据会话的信息；
4. 一个cookie所能保存的数据是有限制的，一般是4KB,很多浏览器会限制一个站点最多保存20个cookie，而session没有数据量的限制，但是，由于session保存在服务器内存中，随着访问量的增加，大量的session将占用大量的服务器资源，一般情况下，服务器会把长时间没有活跃的Session从内存中删除，这个
   时间也就是session的超时时间，如果过了超时时间还没有访问服务器，session也就失效了


## 浏览器输入URL到页面显示的过程
如果使用Https协议，建立三次握手后，会进行SSL或者TSL握手交换密钥



## 阻止new操作抛出异常:一般情况下，在使用new分配内存时，如果没有足够内存，则抛出bad_alloc异常
1. 使用nothrow版本的new
int *p1 = new int;   //内存分配失败时会抛出异常
int *p2 = new (nothrow) int; //分配失败时不抛出异常，而是返回空指针
2. 加一个new_handle函数，通过set_new_handle函数设定，如果分配内存失败，会调用这个new_handle函数



## 空类大小
VS和g++下测试都是1个字节



## 怎么查看死循环进程
1. 首先可以通过top命令查看各个进程对于cpu的占用率，如果是死循环进程，一般是最上面那个cpu占用率最高的那个进程,得到其pid和名称
2. 通过top -H -p pid查看问题出在哪个线程（可以看到其各个线程的cpu占用率，以此可判断哪个线程死循环了，linux里面线程也是进程）
3. 通过gdb ProcessName pid 附加这个进程（主线程中的线程的pid，也可能是主线程）
4. 通过info threads可以查看当前进程在执行哪条语句（在哪一行）



## linux下，有个文件很大占满了磁盘，怎么找出来
利用du -a命令可以查看一个目录下的所有文件的大小

-a：显示查看目录下每个文件的大小
-h: 以kb形式显示

df:显示所有文件系统的信息 



## 如何阻止一个类被拷贝、赋值？
1. 将拷贝构造函数、拷贝赋值运算符声明为private同时不给实现

2. 定义一个基类，构造函数和析构函数为受保护类型，拷贝构造函数和拷贝赋值运算符定义为私有，其它类继承该类

3. 将拷贝构造函数和拷贝赋值运算符定义为delete：C++11中，在函数声明后面加上=delete

## 如何阻止类在栈上创建？
1. 将析构函数设置为私有，然后提供一个公有函数用来执行析构函数，注意不要将构造函数设置为私有，这会使得堆上对象也无法创建

## 如何阻止类在堆上创建
1. 将new delete运算符声明为私有而且不实现


## redis为什么引入跳表而不使用红黑树？
跳表和红黑树都可以实现logn复杂度的单个查询，但是对于范围查询，红黑树要进行中序遍历，过程比较复杂，比较耗时
而跳表本质还是链表，在找到查询起点之后，直接遍历链表到查询终点即可