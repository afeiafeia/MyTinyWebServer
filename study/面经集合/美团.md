<https://www.nowcoder.com/discuss/713234?source_id=discuss_experience_nctrack&channel=-1>
## 一面
手撕代码：
找出二叉树祖先节点与其子节点差值绝对值的最大值

面试题：
1. c语言实现虚函数机制（考察虚函数的原理）

2. 说一说类型萃取机
类型萃取机用于获取模板类型实参的内置类型，或者得到指定类型的模板参数
首先第一点：获取类型的内置类型,如果在实例化一个类模板或者函数模板的时候，类型参数也是一个实例化的模板，那么对于外层的类模板或者函数模板，它所看到的类型是一个模板，至于这个作为类型参数的模板是由哪种具体类型实例化而来的，它是不知道的，因此，如果在这个类模板或者函数模板中想要使用类型参数的具体类型是做不到的；
但是，如果在实例化之前那个作为类型参数的模板中，定义一个内置类型，typedef T type，那么可以通过这个模板得到实例化它的具体类型
第二点：获取指定类型的模板参数
模板是一种编译期的多态技术，在编译时，编译器会根据用户定义的数据自动推断类型来实例化模板，但是这种自动推断可能会带上const 、*等修饰符，而有时候，我们有不想要这样的修饰，只想要保留最原始的实际类型（例如int、double、class A），
这时可以通过模板的特化来实现，例如C++萃取机的remove_const
```c++
template <typename Ty>
struct remove_const
{
    typedef Ty  type;
}

特化一个参数带有const的版本：
template <typename Ty>
struct remove_const<const Ty>
{
    typedef Ty type;
}
```

3. move、forward的原理，emplace高效的原因
(1)move、forward原理：
二者都是标准库中单函数模板。
move用于获取左值的右值引用，实际上是一种右值引用的强制转换；
forward是完美转发，一般是用在函数模板的嵌套调用中，保持实参的类型信息（类型的const、左值、右值）；例如两个函数模板的形参都是右值引用，当传递给外层函数一个右值引用类型的实参时，在外层函数里面，它成了一个左值，这时就无法传递给里面调用的内存函数模板，
而forward可以将这个左值转换回右值引用类型，其原理是利用了引用折叠，例如一个函数如下：
```c++
template<class T,class... Args>
void construct(T* ptr,Args&&... args)
{
    //forward完美转发，如果传给construct的参数args是左值，通过引用折叠，Args是左值引用，这是，如果Ty的参数也是右值引用，则args无法传给它，通过forward，会返回一个左值引用，是的可以传给Ty
    //forward返回Args类型的&&,如果Args是左值引用，通过引用折叠，最终返回的是左值引用

    //如果传给construct的参数是右值，Args就是一个不带引用的类型，args就是一个左值，如果Ty是右值引用，则参数无法传给Ty,这时，forward返回右值引用，可以继续传递Ty

    //实现上，forward与move虽然类似，但还是不同的：
    //（1）forward必须通过显示模板实参来调用，即，使用forward时必须加上见括号<>,forward<T>，而不能直接使用forward(args)；但是move是可以的，move不用显示实例化直接使用move(args)即可
    //（2）move操作对象是一个左值，然后把返回对象赋值给一个右值引用，即一定是这种使用方式：Type(具体类型) && = std::move(一个左值) 

    //显示模板实例化：每次调用是加上尖括号，尖括号中是一个类型（可以是具体类型，也可以是模板类型参数（如果是模板类型参数，该forward一定是在一个模板函数中被调用的情况，如本例））
    ::new ((void*)ptr) Ty(std::forward<Args>(args)...);
}
```
(2)emplace高效的原因：
emplace采用可变参数模板，直接在指定点内存上根据传入参数构造对象，相比于传入一个对象，少了一次构造过程


1. 偏特化理解，SPINEA技术
通用模板并不是对任何类型的实参都是合适的，有时可能编译失败或者执行不正确，有些情况下，我们需要将模板类型限制为某个具体类型或者去除一些修饰（例如const、指针、引用等）
在定义模板的时候，可以像函数定义那样为一些类型参数提供一个默认值，这种做法也就成为模板的偏特化，如果是将所有的模板类型都定义一个实参，那就是全特化；
*当特例化一个函数模板时，必须为每一个模板类型参数提供一个实参，即函数模板特化时必须全特化*
*当特例化类模板时，不必为所有模板类型参数提供一个实参，可以只提供一部分，这是成为偏特化*

2. 讲一讲内存池std_malloc（各种内存池的实现原理）
glibc中，使用空闲块链表，glibc2.9中使用16个空闲块链表，每条链表管理一组相同规格的空闲块，空闲块规格由8字节到128字节等分为16组，分别由这16个链表管理；
当用户第一次申请堆内存时，会找到与所申请内存最接近且大于等于申请内存的链表，接着申请40个空闲块大小的内存并调整到4的边界，之后将申请内存前20个空闲块大小的内存等分为空闲块，与后面的剩余空闲块以链表方式组织起来；
接着把链表第一个空闲块传给用户使用，并将其从链表中去除；
当用户再次申请其他大小的内存时，如果匹配的链表不是刚刚具有空闲块的链表，则会把刚刚的剩余部分划分成整数个匹配链表对应的内存块并组织成链表，剩余部分放在内存池中，之后的申请重复上面的操作；
当内存池中剩余内存不够时，会重复上面申请大内存的步骤；
当匹配链表没有空闲块、且内存池内存也不够并无法再从系统申请到内存的时候，会从空闲块尺寸最接近且大于匹配链表空闲块尺寸的链表中找一个空闲块，差分成两部分，一部分作为匹配链表的空闲块然后给用户使用，另一部分放入内存池；


3. 函数指针的使用（*参考C++ Primer,p248*）
与普通指针指向一种类型的对象类似，函数指针指向一种函数类型的对象，函数类型由*返回类型*和*形参类型*共同决定，与函数名无关;
(1)可以通过函数指针而不使用函数名直接定义并实现一个函数，与普通函数的实现一样，只是将函数名替换为函数指针；
``` C++
int Add(int a,int b)
{
    return a+b;
}

int (*ptr)(int a,int b)
{
    return a+b;
}
```
(2)或者通过函数名，将一个函数赋给函数指针：
```c++
int (*ptr)(int a,int b);
ptr = Add;//
ptr = &Add;//加不加取地址符号“&”都可以
```

(3)函数指针形参：（详细看C++ Primer,p222）
形参不能是函数，但可以是函数指针（但函数可以作为实参传递给函数指针类型的形参）；
(4)函数指针作为返回类型（详细看C++ Primer,p223）

4. 讲一讲多态，有哪些种类

*计算机网络部分*
1. 如果对方关闭连接，epoll读文件描述符返回什么事件?
要分对端关闭连接的方式：
* 如果是正常断开（调用close）或者处理该描述符当线程（或者进程）终止   
（1）对于低版本的内核，是返回EPOLLIN，代表数据可读，此时应用层读取数据，得到EOF,判断对端断开了连接；
因此，对于对端断开连接，只能在应用层去判断、处理；   
（2）而对于高版本的内核，引入了EPOLLRDHUP事件，当对端断开连接，读描述符时，目前会返回EPOLLIN|EPOLLRDHUP，
* 如果是对端断电关键，此时不会向套接字中写入任何信息，描述符并没有就绪，这种情况下，另一端是无法知道对端异常断开的；
但可以采用一些方法来得到通知：
（1）开启套接字的keepalive选项，会定期发送心跳包
（2）在应用层实现心跳包
（3）采取动作来发现，如果对端关闭，在继续写入信息时，对端会回复一个RESET,在之后读描述符时，会返回ECONNRESET错误，描述符当就绪事件是EPOLLERR，如果忽略这些错误，继续写入，则会引发一个SIGPIPE信号，默认动作是终止进程。




1. tcp拥塞控制讲一讲

2. tcp四次挥手，服务器端发送到FIN报文的时间差有无限制

*操作系统部分*
1. 虚拟地址的理解

2. mmap系统调用的原理，第一次调用直接分配物理内存吗？
   mmap函数把一个文件或者一个posix共享内存区对象映射到调用进程的地址空间，或者创建一个无名的虚拟内存区域
   主要有以下几个目的：
   （1）程序加载时将可执行文件建立虚拟地址空间的各个虚拟内存区域
   （2）使用普通文件以提供文件映射IO：将文件的高速缓存区（在内核中）映射到用户空间，也就是用户态、内核态虚拟地址都映射到该高速缓存的物理地址空间，这样可以在用户态直接访问原内核态的控件，减少了系统调用以及上下文切换
   （3）使用特殊文件提供匿名内存映射
   （4）使用posix共享内存区对象（she_open）以提供无亲缘关系进程间共享内存区






   2022.3.5笔试
   第二题：给你一个数组，可以对数组任意位置翻转一次，也可以不反转，求连续最大和
   