## HTTP1.0和HTTP1.1的区别
1. HTTP1.0是非持续连接，客户端对html中每一个对象的情况都要建立一次TCP连接，当服务器处理完对一个对象的请求后，会立即断开TCP连接，

2. HTTP1.1支持非持续连接和持续连接，并且默认是持续连接方式，对每个网页文件中的多个对象的请求与响应在同一个TCP连接中传送，当对所有对象的响应完成之后才断开连接，而且是全双工的，即这些请求和响应可以同时进行（也就是支持流水线处理）；要注意，每个单独的网页还是用各自的连接（即两个HTML网页之间不使用相同的连接，而是每个网页都有一个TCP连接，其内的多个对象共用该连接）；对于是否全双工，还待确认！！！！


3. HTTP1.1持续连接的实现借助于相比HTTP1.0新增的请求头字段connection，当connection字段为keep-alive时，表示持续连接，为close时，为非持续连接

4. HTTP1.1中增加了host字段，HTTP1.0中默认每台服务器只绑定一个IP地址，因此在请求头中的URL中没有包含主机名，但是随着虚拟技术的发展，一台服务器主机可能有多个虚拟主机并且共享一个IP地址，这是就无法使用HTTP1.0传递报文，因为没有指定主机名，无法确定将请求送给哪个主机；
相反，HTTP1.1中增加了host字段，在其请求和响应消息中都应该包含host，请求消息如果没包含，会报告一个400(Bad Request)

5. 在建立连接后，HTTP1.0直接传递应用层报文，而HTTP1.1则会首先发送一个不含报文实体的请求，如果服务器因为权限拒绝了请求，就会回复相应码401（Unauthorized）,否则回复100（Continue，这是HTTP1.1中新增的状态码），之后客户端再发送包含实体的完整报文，通过这种方式，可以在发送消息之前检测一下；

6. 虽然HTTP1.1可以在一个TCP连接中传递多个请求，但它们实际上是串行传送的，而且，服务器对请求的响应必须按照客户端请求的顺序，以保证客户端能够区分出每次请求的响应内容；例如：客户端请求两个对象1、2，如果对象2的请求资源先准备就绪，也不会提前相应对象2，而是等对象1点请求资源就绪后，再依次响应对象1、对象2；
<https://www.cnblogs.com/gofighting/p/5421890.html>


## HTTP1.1和HTTP2.0区别
1. HTTP1.1 **直接将字符形式的请求报文**交付给TCP层进行传输，服务器端收到后，在应用层必须解析出请求head和body才能完成通信。
2. HTTP 2.0 将应用层的数据经过**二进制帧层处理**，将不同的请求拆成不同的流标识符stream，由stream的id进行标记，请求的stream被分割成多种类型的帧，其中包括head帧和data数据帧。正是因为有了stream的id标记、以及各种不同类型的帧，确保了请求和响应的有序重组。

3. 在HTTP2.0中，每个对象的请求是一个数据流，数据流以消息的方式发送，而消息被分为多个帧，帧头部记录了stream id用来表示该帧所属的数据流，接受方根据stream id将帧归入相应的数据流

4. HTTP2.0可以对每个数据流设置优先级和依赖，优先级高的数据流会被服务器优先处理并返回给客户端，数据流可以依赖其它数据流
5. HTTP2.0实现了真正的并行传输，能够在一个TCP连接上进行任意数量的HTTP请求
6. 头部压缩，在HTTP1.x版本中，头部元数据都是以纯文本形式发送的，通过给每个请求增加了一定的符合，比如cookie，浏览器每次请求的时候，把**cookie附在请求头上**发送给服务器，而HTTP2.0中，使用encoder来减少传输的头部大小，通讯双方各自缓存一份头部的表，避免了重复传输；
7. 服务器推送：HTTP2.0实现了服务器推送，服务器除了对客户端的响应外，可以主动向客户端推送资源，而无需客户端提前请求
<https://segmentfault.com/a/1190000013028798>