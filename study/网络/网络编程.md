## select、poll、epoll

select函数

允许进程指示内核等待多个事件中的任一个发生，并在一个或多个事件发生时或者阻塞时间达到通过select设置的参数值后，唤醒进程；进程在进行select系统调用时进入阻塞状态

poll的功能类似于select，不过在处理流设备时，它能够提供额外的信息,poll使用结构数组来描述需要监视的描述符以及需要监视的状态（例如监视套接字是否可读、可写、发生错误等）

select、poll都有一个时间有关的参数来指示需要监视多久，如果在指定时间内没有任何描述符处于所监视的状态，将从该系统调用返回，进程继续向后执行；

***区别***
1. select的时间参数是一个指针，poll是一个对象，
2. select的时间单位是秒或者微秒（时间参数是一个结构体，里面两个成员，一个指定秒数另一个指定微秒数）；而poll的时间参数是一个int值，单位是毫秒；
 
3. 对于select，如果传入空指针，进程将一直等待下去直到所监视的描述符达到监视的状态
通过传入一个timeval对象指针，指示内核监视多久:如果对象中的时间是0，表示立即返回，此时，如果在执行到检查描述符状态是否就绪时（FD_ISSET）,描述符还没有就绪，这继续往后面执行，这样等到后面就绪了，也不会再处理（已在网络编程Socket文件的select文件中代码验证）；如果是一个正值，表示监视的时间；对于poll，时间用一个int值来表示，INFTIM表示无限等待，0表示不等待直接返回，大于0表示等待指定数目的毫秒数

4. 当发生错误时，poll返回-1，当达到时间限制但是没用描述符就绪时，返回0，当时间限制内描述符就绪，返回就绪的描述符数目

5. 对于epoll，有两种触发方式，水平触发（LT）和边缘触发（ET）,而select、poll没有触发模型的选择，只能水平触发；
   
   *水平触发与边缘触发*
   （1）水平触发（LT）：当被监视的描述符或者说事件就绪（处于需要监视的状态）时，内核会通知进程，如果进程不进行处理或者处理不完全（例如一个描述符可读，但是没用从缓存区取走数据或者只是取走一部分），当下次再检查该描述符（事件）的状态时，依然是就绪的，依然会通知进程（例如select中，使用FD_ISSET检查依然是true，epoll中使用epoll_wait,为true）
   （2）边缘触发（ET）:当被监视的描述符就绪时通知进程，如果进程不处理或者处理不完全(例如套接字可读时，没有读取完所有数据)，描述符也会回到未就绪状态，不会再通知进程直到再次达到就绪状态，直到再次往套接字写入数据

<https://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html>
<https://zhuanlan.zhihu.com/p/159135478>
<https://www.cnblogs.com/fchy822/p/8857254.html>
<https://blog.csdn.net/HUAERBUSHI521/article/details/118303728>


## 四次挥手看到后台很多timewait是正常的还是不正常的，什么问题?
这种情况是正常的，在高并发短连接的情况下，业务处理+分组的传输时间要远小于整个TCP的生命周期，在一个业务处理完成后，TCP还要存在一段时间才能断开，而且主动断开的一端主要处于Time_Wait时期，由于高并发，短时间内，大量的业务得到处理但还都处于四次挥手的Time_Wait状态没有断开；
存在问题：虽然业务处理已经完成，但是由于TCP没有断开，仍然占据端口，导致此端口无法被其他需要的请求使用，而端口数量又是有限的，可能导致后期大量的请求无法实现TCP连接；
一方面，如果是短连接，对每一个对象的请求会有一个TCP连接，当服务器响应对象的请求后，即发起断开连接，如果一次请求例如对一个Web页面的访问，存在多个对象，那对该Web页面的请求会产生多个TCP连接，导致占用多个端口而且较长一部分时间是处于Time_wait状态，这种情况可以改为长连接，将请求头的connection字段由close改为keep-alive;
<https://www.cnblogs.com/dadonggg/p/8778318.html>


## 如何从套接字中取数据
当通过write将待发送的数据从进程缓冲区复制到内核中该套接字的发送缓冲区后，对于TCP，内核根据最大分节MSS的大小为单位取数据，当缓冲区中数据小于MSS时，直接取；例如发送缓冲区中有1100字节的数据，MSS为500，则首先取500字节，再加上TCP首部封装成TCP报文沿协议栈向下传递给IP协议栈，再取500，进行同样的操作，最后剩下100字节，小于MSS，直接直接取然后同样的操作；
另外，TCP的发送缓冲区必须为已发送的数据保留一个副本，直到它被对端确认为止，才能从缓冲区中删掉已确认的数据，也就是说，当从内核缓冲区中取数据后，并不会立即将这段数据从缓冲区移除，而是等到收到对端的确认报文后才删除，这样，如果没有收到，则可以继续重新发送；
### TCP缓冲区的调用顺序
当设置TCP套接字缓冲区大小时，函数的调用顺序很重要。因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户端，这意味着缓冲区选项必须在调用connect之前设置。对于服务端，这意味着该选项必须在调用listen之前给监听套接字设置，已连接套接字的缓冲区大小总是从监听套接字继承而来


对于UDP,实际上不存在发送缓冲区，但存在一个发送缓冲区大小，它表示可以写到套接字的数据报大小上限，当写入时，如果数据大小小于此值，可以正常写入然后向下传递、最终发送出去，但是当想要写入的数据报大于该值时，写入将失败，返回一个EMSGSIZE错误（error==EMSGSIZE）

## 接受缓冲区
TCP有发送缓冲区和接收缓冲区
UDP没有发送缓冲区，但是有接收缓冲区，它是一个队列，接收的每一个UDP数据报作为一个元素放在队列中，因此，UDP是存在消息边界的，不会出现粘包

<Unpv2 8.1p187>
写一个长度为0的UDP数据报是可行的，这会形成一个只包含IP首部（IPv4首部20字节，IPv6首部40字节）和UDP首部（8字节）的IP数据报;
因此，对于UDP数据报，recvform返回0值是可接受的，并不像TCP，read返回0值表示对端关闭连接



# select 、poll、epoll原理、区别
## select：
（1）首先定义三种描述符集合（由于监视可读、可写、发生错误三种状态）FD_SET，实际上是一个数组,数组的大小跟所监视的最大描述符而不是描述符数量有关，即一段连续地址空间，select将其作为位图来使用，使用其中的每一位标识一个描述符，然后将需要关注描述符添加到指定描述符集合中；

（2）此时进程阻塞在select的调用上；之后描述符集合被拷贝到内核，内核轮询每一种描述符集合中的每一个描述符，当发现一个描述符达到所监视的状态时，将其它描述符对应的位清0，之后从select返回；

（3）在进程后，从select返回后，通过遍历每种描述符集合中每一个点状态来判断哪一个描述符就绪了，然后执行相应的处理

### 优点：

（1）select遵循POSIX标准，可以跨平台移植

（2） select的等待时间可以精确到微秒（poll和epoll只能到毫秒）

### 缺点：
（1）需要将描述符集合从进程拷贝到内核，然后内核轮询关注的每一个描述符，直到发现有就绪的描述符，当关注的描述符很多时，将带来效率的降低

（2）select所能监视的描述符数量有上限，通过宏*__FD_SETSIZE*来决定，默认是1024个

（3）当从内核返回后，用户也需要遍历每个描述符来寻找就绪的描述符

（4）每次找到就绪的描述符，会将其它描述符的位被置为0，如果需要继续监控某些描述符，需要再次将它们添加到集合中


## poll 
（1）对于每一个需要监视的描述符，定义一个pollfd结构体，用于记录需要监控的描述符以及监控的状态和之后就绪时返回的状态  
（2）poll函数中传入pollfd数组和大小以及等待时间，该数组将同样被拷贝进内核，内核轮询数组中的描述符，当找到就绪的描述符时返回到进程；  
（3）进程中，从poll返回后，遍历pollfd数组寻找就绪的描述符

### 优点： 
（1）将监视的描述符以及监视的状态放入结构体中，相比select分成三个描述符集合，得到简化  
（2）可以监视的描述符数量没有限制  
 (3)每次返回后，其它未就绪的描述符可以继续通过调用poll监视，不要再次向数组中添加

 ### 缺点  
 （1）需要拷贝到内核而且内核轮询描述符，效率会随着描述符当增加而下降   
 （2）仍需要进程遍历来查找就绪描述符，效率随着描述符增加而下降   
 （3）无法跨平台移植    
 （4）等待时间只能精确到毫秒



 ## epoll
 epoll用于实现IO复用，IO复用的原理是进程提前告知内核需要关注哪些描述符上的哪些事件（例如可读、可写、异常等等），等这些相应事件发生时通知进程；
 epoll通过一组函数来实现IO复用，区别与select和poll使用一个函数；
 （1）首先通过epoll_create()函数直接在内核创建一个eventpoll结构体，返回一个描述符作为操作句柄 
 epoll_create（size_t size）;size是监视的描述符数量，实际上可以监视的数量远比该值大，在实际使用时，传入一个大于0的值即可，实际监视的描述符数量跟该值大小没关系（在linux内核源码中，它只被用来检查是否大于0 <https://blog.csdn.net/junlon2006/article/details/101202705>）  
 （2）之后通过epoll_ctl添加需要监视的描述符以及监视的状态或者进行修改、删除，对于添加到每一个描述符上的事件，内核会为其设置一个回调函数，这些监视的事件对象（epoll_event）通过红黑树进行管理；    
 （3）使用epoll_wait()进行监视，epoll的监视是一个异步阻塞操作，操作系统为每一个描述符所需要监视的状态设置了一个回调函数，一旦该描述符就绪，就会自动调用回调函数，将描述符所对应的epoll_event结构体添加到双向链表中  
 （4）操作系统每隔一段时间去检查一下双向链表是否为空（这是一个阻塞操作，如果不为空或者超时才返回），根据返回状态判断是否为空，如果不为空，则将就绪的描述符当epoll_event添加到通过epoll_wait()传入的数组中,进程遍历数组判断就绪的描述符当状态，执行相应处理    

 ### 优点
 （1）底层用红黑树存储监视的描述符，监视的描述符数量没有上限，插入、删除都很方便（时间复杂度）   
 （2）监视信息只需在通过epoll_ctl添加时向内核拷贝一次    
 （3）采用异步阻塞方式，性能不会随着描述符数量增加而下降     
 （4）直接返回了就绪的描述符，进程不需要遍历去判断哪个描述符就绪   

 ### 缺点  
 （1）无法跨平台移植   
 （2）等待时间只能精确到毫秒    
 （3）在活跃连接较多的时候，会大量触发回调函数，会降低效率，甚至比select、poll效率低，正因此，epoll一般用于监视数量多但是活跃的少的情况     

## EPOLLIONESHOT事件：（linux高性能服务器9.3.4节）
在一个线程处理套接字上的数据时，套接字再次变为可读，此时会有另一个线程被唤醒用来处理新到的数据，这就导致在同一时刻，有多个线程处理同一个套接字，一般情况下，应该避免这种情况；解决方案：
为套接字描述符注册EPOLLONESHOT事件：对于注册了EPOLLONESHOT事件的描述符，操作系统最多为其触发一个事件（可读、可写或者异常）且只触发一次；
但要注意的是，当处理完成之后，应该重新修改套接字描述符（*EPOLL_CTL_MOD：修改已经注册的fd的监听事件*），这样之后描述符再次可读时，可以被其它线程处理，否则，描述符无法再次被触发；
EPOLLONESHOT事件确保一个TCP连接在其整个生命周期只被一个线程（或者进程）处理
在TinyWeb项目中，在http_coon的process中，在处理完请求后，会重新修改描述符上的时间

## EPOLLRDHUP、EPOLLERR、EPOLLHUP事件
1. EPOLLRDHUP：对端关闭连接,调用close或者shutdown会触发该事件，异常点断开不会触发这个事件
2. EPOLLERR：对于文件描述符当操作发生错误，例如对一个关闭了读端的管道进行写操作
3. EPOLLHUP:对端关闭时（可以是不正常关闭），触发该事件
* man epoll_ctl命令查看
  <https://blog.csdn.net/q576709166/article/details/8649911>


如果对方关闭连接，epoll读文件描述符返回什么事件????
<https://blog.csdn.net/yongqingjiao/article/details/78819791>
<https://www.nowcoder.com/discuss/713234?source_id=discuss_experience_nctrack&channel=-1>
<https://zhuanlan.zhihu.com/p/387831204>
<https://blog.csdn.net/wwxy1995/article/details/100785832?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.essearch_pc_relevant&spm=1001.2101.3001.4242>
<https://blog.csdn.net/swty3356667/article/details/84332472>

TCP相关问题
<http://t.zoukankan.com/huajiezh-p-7492416.html>

## TCP粘包问题：
粘包现象：发送端发送到多个数据包在接收端粘成一个包，从接受缓冲区看，多个包的数据首尾相连，无法区分；
首先这个数据包是指应用层请求报文，而不是TCP报文；
产生原因：分为两种：
（1）发送端造成：TCP提供可靠数据传输，对每一个请求都要收到一个回复，因此，相比于无连接的不提供可靠性的传输，增加了额外开销。对于每一个放到发送缓冲区的请求报文，TCP按照最大分节大小取数据进行封装，如果当前缓冲区中的数据小于最大分节大小时，直接取走，因此，如果写入发送缓冲区的速度较慢或者发送端从发送缓冲区取出数据过快，可能取出的是大量的短小的数据流，而这每一个数据流都会被封装成一个TCP报文，接收端会对其进行响应；这必然也就会增加开销；因此，TCP采用了优化算法，会等到发送缓存中存在足够数据后才取出发送，这就造成一个问题，如果缓冲区中的数据属于不同的请求，而且每个请求报文不是恰好等于最大分节大小，那么在取数据的时候，就会出现不同请求放置到一个包的情况，这就造成粘包；
这些数据再被放到发送端的发送缓冲区后，发送端无法确定边界；
（2）接收端造成：当接受端从接受缓存区中读取数据太慢时，可能出现一个请求还未读取完成，下一个请求报文就被放入缓冲区，此时继续按照预定的值进行数据读取时，就可能会读到属于另一个请求的数据，这必然导致无法正确解析出发送端的请求。

解决措施：
（1）发送固定长度的消息，保证每个报文都是最大分节大小的整数倍
（2）把消息的尺寸和消息一起发送：例如Http报文的实体体部分，其长度记录在首部行的Content-Length字段
（3）使用特殊标记来区分不同的请求:以特殊的字符或者字符串，例如http协议的请求头部、首部行、空行以\r\n作为分隔符
<https://www.cnblogs.com/kex1n/p/6502002.html>



## 套接字选项
<https://blog.51cto.com/xwandrew/2046615>
SO_LINGER
```c++
struct linger
{
   int l_onoff; //0表示关闭此选项，1表示开启
   int l_linger;//时间
}
```

设置 l_onoff为0，l_linger的值被忽略，等于内核缺省情况，close调用执行四次挥手过程，TCP模块负责尝试发送残留的缓冲区数据。


设置 l_onoff为1，l_linger为0，则连接立即终止，close调用立即返回，TCP将*丢弃*残留在发送缓冲区中的数据*并发送一个RST给对方*，而不是通常的四分组终止序列，这避免了TIME_WAIT状态；在远端的recv()调用将以WSAECONNRESET出错。

设置 l_onoff 为1，l_linger > 0：
 如果socket为阻塞的，则close将阻塞等待l_linger 秒的时间，如果在l_linger秒时间内，TCP模块成功发送完残留的缓冲区数据，并且close返回0，表示成功，然后执行挥手过程。如果l_linger时间内，TCP模块没有成功发送完残留的缓冲区数据，则丢弃发送缓存区中的数据，并且close返回-1，表示失败，并将errno设置为EWOULDBLOCK，然后执行挥手过程。
  如果socket为非阻塞，close立即返回，此时需要根据close返回值以及errno来判断TCP模块是否成功发送残留的缓冲区数据。
<https://zhuanlan.zhihu.com/p/102810684>
<https://blog.csdn.net/songchuwang1868/article/details/90369445>
<https://cloud.tencent.com/developer/article/1814410>

## 长连接与短链接
<https://cloud.tencent.com/developer/article/1647317?from=article.detail.1814410>




## 为什么IO复用要配合非阻塞IO使用？<https://mp.weixin.qq.com/s/nacUx_qQr93_y-CsVxkejA>
(1) 数据到达socket缓冲区，socket变为可读，IO复用函数返回，但此时缓冲区中的数据可能被丢弃，比如校验和错误，此时如果采用阻塞IO，会造成阻塞；
(2)对于epoll，在ET模式下，读取数据时的操作是循环读取直到返回EAGAIN或者EWOILDBLOCK,而如果是阻塞式IO,循环的最终必然是阻塞
(3)惊群效应：如果多个线程或进程都在等待同一个事件的发生（例如等待某个描述符可读），当事件发生时，内核会唤醒所有的线程或进程，当其中一个读取完成后，其他线程或进程再读取，如果是阻塞式IO，这些其他线程或进程就会被阻塞在IO上(*这一条理由不正确*)；

*惊群效应*：多个进程或线程等待同一个事件的发生，当事件发生时，内核会唤醒所有的进程/线程,而最终只有一个进程/线程得到事件并进行处理，其他进程/线程继续进入阻塞状态；
*惊群效率所带来的问题：*
(1)所有的进程/线程都被唤醒，然后除了得到事件的进程/线程，其余的又重新进入休眠状态，期间产生大量的上下文切换；
(2)多进程/线程争抢资源，需要加锁，这又会带来开销
<https://blog.csdn.net/lyztyycode/article/details/78648798>



##　网络包到达网卡后的过程
网卡收到网络包后通过DMA将数据搬运到网卡中的一个环形缓冲区，网卡收到数据后，通过中断的方式通知系统，之后中断服务例程从网卡中取数据存入sk_buff结构，
向上传给协议栈进行处理；
(1)首先是传递给链路层，在这一层检查报文的合法性，不合法则丢弃，如果合法，首先找出网络包的上层协议类型，比如是ipv4还是ipv6，然后去掉帧头帧尾
(2)然后传递给网络层，首先对分片的IP报文进行合并恢复原始报文，然后取出IP头部，判断是TCP还是UDP，然后传递给相应的运输层协议栈；
(3)传递给运输层之后，根据源IP、目的IP、源端口、目的端口找到相应的套接字，然后将sk_buff信息传递给这个套接字结构
之后用户态可以调用套接字接口进行报文的读取
