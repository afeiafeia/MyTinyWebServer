## 五种IO模型
**阻塞式IO**

**非阻塞式IO**

对于描述符，如果不能立即进行，error被置为EAGAIN或者EWOULDBLOCK(*跟系统有关*，详看UNP p339)


**IO复用**

**信号驱动式IO**

**异步IO**

1. 阻塞式IO
   在进行IO时，进程进行系统调用，操作系统陷入内核态，而进程进入阻塞状态，直到系统调用返回（IO完成或者出错）

2. 非阻塞式IO
   进程通过把一个套接字设置成非阻塞，来使得对此套接字的IO操作不使进程进入阻塞状态，而是使得相应的系统调用返回错误，进行不断的检查直到IO操作完成，这种方式虽然没有阻塞进程，但进行也只能忙等待，做不了其他事情
   非阻塞式IO通常配合其他IO机制使用，常用的是IO复用和信号驱动IO；
   针对非阻塞IO的系统调用会立即返回，如果事件没有准备好（例如不可读时进行读操作），系统调用会返回-1，这跟系统调用出错的情况一样，需要通过error的值来区分这两种情况（IO没准备好、出错），
   如果是没准备好，error是EAGAIN或者EWOULDBLOCK(*linux高性能服务器，8.3节*)

3. IO复用
   其原理是使进程阻塞在select、poll的调用上，而不是后面的IO系统调用上，当select、poll中的一个或多个描述符的IO操作完成时，会从系统调用返回到进程，使得进程在进行该描述符的IO操作使不会进入阻塞状态
   作用：在回射客户端-服务器模型中，服务器将用户输入到套接字的内容回射回客户端，在客户端等待用户输入或者输入完成之前，客户端处于阻塞状态，如果此时服务器宕机或者一些其它原因导致向套接字写入一个错误EOF，这是客户端将不能及时获取该进行，而要等到输入完成，如果采用IO复用，虽然对缓冲区的写入阻塞，但是出错时套接字被写入信息，IO操作完成，客户端不再阻塞，继续执行，处理套接字中的输入信息，可以立刻发现因服务器端的故障导致连接的断开
   **用于对大量描述符进行IO就绪事件监控,能够让用户只针对就绪指定事件的描述符进行操作**
   **避免了对没有就绪的描述符进行操作而带来的阻塞,同时只针对已就绪的描述符进行操作,提高了效率.**

4. 信号驱动式IO
   让内核在指定描述符IO就绪时发送一个信号给进程，进程去执行相应的信号处理函数进行处理（这种方式下，进程不阻塞也不会忙等待）
   原理：首先开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数来进行数据的处理，该系统调用返回后，进程继续向下执行，当数据准备好IO时，内核向进程发送一个信号，然后进程去执行信号处理函数进程数据的处理

5. 异步IO：（*linux高性能服务器，p127*）
同步IO与异步IO：
阻塞IO和非阻塞IO以及IO复用都是同步IO，同步IO是指当IO就绪的时候，IO操作完成才会返回，以读操作为例，对于同步IO，当描述符可读的时候，读取时，直到将指定数据读到缓冲区，读操作才返回；
而对于异步IO，当IO就绪的时候，调用函数进行IO时，会立刻返回；以读为例，此时数据还没有读到缓冲区，之后内核会将数据拷贝到缓冲区，完成之后通知进程读操作完成，此时进程可能从缓冲区取数据使用；

同步IO模型是进程执行IO操作，将数据从内核高速缓存读到用户空间的缓冲区，或者将数据从用户空间缓冲区读到内核高速缓存，同步IO向进程通知的是IO就绪事件；
异步IO模型是内核执行IO操作，向进程通知的是IO完成事件



磁盘IO的方式：
（1）文件IO
（2）标准IO
（3）存储映射IO

（1）文件IO：每次读写都会进行系统调用
文件IO是不带缓冲的IO，这个缓冲是指应用进程空间的IO，但无论哪种IO,内核中都存在一个缓存区（一般是缓冲区高速缓存或者页高速缓存），在写入时，都会写到内核所设的该缓存中而并非直接写到磁盘上，    
同样，读取时，也不是每次都从磁盘读取，系统会将文件放入高速缓存中，如果高速缓存中没有数据，会将进程挂起，将请求放入磁盘磁盘的请求队列，当磁盘将数据放到高速缓存后，进程再从缓存区读取；如果高速缓冲区有数据，则直接读取

当写入数据时，write是将数据从用户空间复制到内核缓存区中，然后返回，注意，write并没有将数据写入磁盘上，当内核缓冲区满后或者内核要使用缓冲区存放其他磁盘块信息时，缓冲区中的内容会被放入磁盘的输出队列（写队列）中，磁盘定期将输出队列上的数据写到磁盘，但也可以通过设置文件状态标志来将数据真正写入磁盘；
对于输入而言，read系统调用从内核高速缓存中取数据，直至把缓存中的数据取完，此时内核会将文件下一段的内容读到缓存中，等待read读取（一般内核会进行预读，来使得数据被read系统调用读取之前已经在缓存中了，避免由于不在缓存引起的阻塞）
从内核2.4开始，Linux 不再维护一个单独的缓冲区高速缓存。相反，会将文件I/O缓冲区置于页面高速缓存中，其中还含有诸如内存映射文件的页面

有以下几个函数：
1. void sync(void);该函数将缓冲区上的内容放到磁盘的写队列中，但并不等待写入磁盘；一般情况下，系统内update进程周期性的调用sysc()函数，将缓冲区数据放入磁盘写对列，这也就实现了缓冲区的冲洗
2. int fsync(int fd);将文件描述符fd对应的缓冲区数据写入磁盘，不仅放入队列，而且写入磁盘，数据真正写到磁盘上后，该函数才返回
3. int fdatasync(int fd);
*Unix 环境高级编程 3.13* 
 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销！！！

（2）标准IO
标准IO是带缓冲的IO，一般是库函数（linux使用glibc库），它是在文件IO的基础上进行了封装，读写的时候，实际上操作的是缓冲区，当达到一定条件后，隐式进行系统调用将缓存区中的数据写到文件或从文件读到缓存区
这个条件一般分为三种情况：
1. 全缓存：填满IO缓冲区后才进行1实际的IO操作
2. 行缓存：读写时遇到换行符，执行实际的IO操作
3. 不带缓冲：

文件IO用文件描述符表示一个文件，可以操作的文件有普通文件、设备文件、管道、套接字文件等
标准IO用流来表示文件，通常只能访问普通文件；
<https://www.cnblogs.com/tianzeng/p/9347612.html>
<https://blog.csdn.net/qq_30592303/article/details/108133177>

用户进程缓存区：*减少了系统调用的次数*
        用户进程通过系统调用访问系统资源的时候，需要切换到内核态，而这对应一些特殊的堆栈和内存环境，必须在系统调用前建立好。而在系统调用结束后，cpu会从核心模式切回到用户模式，而堆栈又必须恢复成用户进程的上下文。而这种切换就会有大量的耗时。

       你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。（用较小的次数填满buffer）。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。

       所以说：用户缓冲区的目的是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。

内核缓存区(高速缓存)：*减少了磁盘访问的次数*
       当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的io模型，在调度和使用内核缓冲区的方式上有所不同。

     你可以认为，read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。当然，write并不一定导致内核的写动作，比如os可能会把内核缓冲区的数据积累到一定量后，再一次写入。这也就是为什么断电有时会导致数据丢失。所以说内核缓冲区，是为了在OS级别，提高磁盘IO效率，优化磁盘写操作。

 

缓存和缓冲的区别
缓存（cache）把常用数据存储到可以快速获取的区域(缓存区)，以备重复利用，提高效率。
缓冲（buffer）在数据流转过程中，不同层次数据速度不一致时，利用缓冲区来缓解上下层之间速度问题，增加速度。
————————————————
版权声明：本文为CSDN博主「PerseverancePrevails」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_30592303/article/details/108133177



   <https://www.cnblogs.com/huxiao-tee/p/4657851.html>



   (3)内存映射IO
   将内存设备对应的物理缓存区（物理页面）映射到用户空间，用户态进程可以直接访问原本映射到内核态的物理内存，进程通过对该段内存的读写来实现对设备的读写，相比与文件IO或者标准IO,    
   一方面，省去了内核缓存与用户进程缓冲区之间的数据拷贝；另一方面，进程直接访问原本要通过内核访问的内存，省去了系统调用的开销；
   <https://blog.csdn.net/goodluckwhh/article/details/16870101?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link>
   
   <https://rtoax.blog.csdn.net/article/details/108885346?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link>



   ## 高级IO(UNPv1)
   recvfrom超时时，errno被置为EWOULDBLOCK