运输层协议TCP和UDP最基本作用：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程间的交付服务；    
将主机间交付扩展为进程间交付称为运输层的多路复用与多路分解；   
进程间的数据交付和差错检查是运输层提供的最低限度的服务，也是UDP所提供的仅有的两种服务；   
## UDP
UDP是提供不连接不可靠的服务，仅提供数据交付和差错检查两项运输层所提供的基本服务；而且，对于出错的报文，UDP无法进程恢复，要么丢弃报文要么向进程发出警告；   
相比与UDP，TCP提供面向连接的可靠数据传输服务：   
（1）面向连接：在使用TCP进行数据传输之前，需要在传输进程间通过三次握手建立连接；当终止数据传输时，需要通过四次挥手断开连接；    
（2）可靠数据传输：TCP通过流量控制、序号、确认号、超时重传机制保证数据顺利、按序、准确交付；     
（3）TCP还提供拥塞控制，可以根据当前网络的拥塞程度调节发送速率，UDP不提供拥塞控制，

TCP是如何确保可靠数据交付的？？？     
（1）TCP通过序号、确认号保证报文顺利、按序交付
TCP将数据看成无结构的、有序的字节流，因此每个字节都有一个字节流编号，TCP传送数据的时候，从发送缓存中按照最大报文段长度（MSS）取数据，作为报文段的数据，该段数据的首字节的字节流编号作为TCP报文段首部的序号字段，当对端收到报文后，会在响应报文的TCP首部字段填入填入一个确认号，它是请求报文的序号字段加上其长度，表示已经收到该序号的报文，期待已确认号为序号的下一个报文；TCP只会对第一个丢失字节之前的报文进行确认（累计确认），对于丢失字节后面正常到达的请求报文，服务器端不对其进行确认，但至于是丢弃他们还是保留等待丢失字节到达取决于TCP编程人员实现；
（2）TCP采用重传机制来处理报文段的丢失问题：有以下几种方式：
1. 超时重传：设置超时时间：当发送一个TCP报文后开启定时器，时间到达超时时间时如果还没有收到此报文的确认报文，就重传该报文
2. 快速重传：服务器端收到失序报文后，重复确认最后一个按序达到的报文，客户端TCP在重复收到某个确认报文后，认定该报文后面的报文丢失，于是重传后续的那个报文； 这里引出一个问题：当重传丢失的报文后，后续原本正常到达的报文还需要重传吗？这取决于服务器端：
   * 回退N步：如果服务区丢弃了失序报文，则会让客户端继续重传；
   * 选择重传（许多TCP实现采用这种方式:*自顶向下p163*）：如果将失序报文缓存起来，等原先丢失的报文再次到达后，所有报文都顺利到达了，直接确认最后报文即可；
（3）除了对于丢失报文的处理，TCP还通过流量控制和拥塞控制来避免或者降低报文丢失发生的概率：
1. 流量控制：TCP报文段首都有一个接受窗口字段，用于接受方给发送方一个提示:提示发送方，接受方的接受缓存还有多少空间，
2. 拥塞控制：当网络拥塞时，大量分组滞留在路由器的缓存中，当缓存满了后，后续的分组就会被丢弃造成丢包，TCP











## 四次挥手看到后台很多timewait是正常的还是不正常的，什么问题?
这种情况是正常的，在高并发短连接的情况下，业务处理+分组的传输时间要远小于整个TCP的生命周期，在一个业务处理完成后，TCP还要存在一段时间才能断开，而且主动断开的一端主要处于Time_Wait时期，由于高并发，短时间内，大量的业务得到处理但还都处于四次挥手的Time_Wait状态没有断开；
存在问题：虽然业务处理已经完成，但是由于TCP没有断开，仍然占据端口，导致此端口无法被其他需要的请求使用，而端口数量又是有限的，可能导致后期大量的请求无法实现TCP连接；
一方面，如果是短连接，对每一个对象的请求会有一个TCP连接，当服务器相应对象的请求后，即发起断开连接，如果一次请求例如对一个Web页面的访问，存在多个对象，那对该Web页面的请求会产生多个TCP连接，导致占用多个端口而且较长一部分时间是处于Time_wait状态，这种情况可以改为长连接，将请求头的connection字段由close改为keep-alive;
<https://www.cnblogs.com/dadonggg/p/8778318.html>


## 如何从套接字中取数据 
当通过write将待发送到数据从进程缓冲区复制到内核中该套接字的发送缓冲区后，对于TCP，内核根据最大分节MSS的大小为单位取数据，当缓冲区中数据小于MSS时，直接取；例如发送缓冲区中有1100字节的数据，MSS为500，则首先取500字节，再加上TCP首部封装成TCP报文沿协议栈向下传递给IP协议栈，再取500，进行同样的操作，最后剩下100字节，小于MSS，直接直接取然后同样的操作；
另外，TCP的发送缓冲区必须为已发送的数据保留一个副本，直到它被对端确认为止，才能从缓冲区中删掉已确认的数据，也就是说，当从内核缓冲区中取数据后，并不会立即将这段数据从缓冲区移除，而是等到收到对端的确认报文后才删除，这样，如果没有收到，则可以继续重新发送；
### TCP缓冲区的调用顺序
当设置TCP套接字缓冲区大小时，函数的调用顺序很重要。因为TCP的窗口规模选项是在建立连接时用SYN分节与对端互换得到的。对于客户端，这意味着缓冲区选项必须在调用connect之前设置。对于服务端，这意味着该选项必须在调用listen之前给监听套接字设置，已连接套接字的缓冲区大小总是从监听套接字继承而来

* Unix网络编程卷一：2.11 P49 *
对于UDP,实际上不存在发送缓冲区，但存在一个发送缓冲区大小，它表示可以写到套接字的数据报大小上限，当写入时，如果数据大小小于此值，可以正常写入然后向下传递、最终发送出去，但是当想要写入的数据报大于该值时，写入将失败，返回一个EMSGSIZE错误（error==EMSGSIZE）