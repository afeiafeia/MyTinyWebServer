TCP的断开连接（四次挥手）：
不同于建立连接的三次握手，TCP的断开连接是在应用层调用close实现的，需要连接的两端都调用close();
## 正常情况下的断开：（以服务器先断开为例）
1. 服务器进程调用close(fd),向客户端发送一个FIN分节，同时进入FIN_WAIT1状态；
2. 客户端收到FIN后，回复一个ACK（*注：TCP中，ACK的回复在内核进行，应用层感知不到*），同时客户端进入CLOSE_WAIT状态；
3. 此时客户端的读操作返回一个EOF，（客户端据此判断服务器断开了），于是调用close(fd),(*注：这些close都是应用层代码,虽然正确情况确实应该这么些，但可能有的客户端代码就是不调用close(),这也必然导致断开不能正常进行*)    
   调用之后，客户端向服务器端发送FIN分节，客户端由CLOSE_WAIT状态进入LAST_WAIT状态；

4. 在服务器端收到客户端的回复的ACK报文后，进入FIN_WAIT2状态；
5. 在服务器端收到客户端发送的FIN后，回复一个ACK，同时由FIN_WAIT2状态进入TIME_WAIT状态；
6. 客户端收到服务器端回复的ACK后，断开连接
7. 服务器端，在TIME_WAIT状态等待2MSL时间后，断开连接


## 异常情况
（1）客户端读到EOF后（说明服务器端发送了FIN），没有调用close(),这分为几种情况：
  1.客户端什么都不做:客户端的连接一直处于close_wait状态
  2.客户端忽视该FIN分节，继续与服务器通信：客户再继续发送数据时，服务器对其响应一个RST（这将导致客户端的连接被关闭*netstat -t将查不到这个连接*）,之后如果客户端读套接字，将返回0，但errorno并没有被置为ECONNRESET错误，如果客户端收到RST后不读，而是继续写，内核会向进程发送一个SIGPIPE信号,
    该信号的默认动作是终止进程，当然也可以捕捉或者忽略该信号，之后，write函数将返回一个EPIPE（error = EPIPE）错误
    *如果接收到reset报文，如何关闭？？？*发送RST报文的一端直接丢弃发送缓冲区和接受缓冲区中的数据,然后立即发送RST报文*随即断开了连接，不会存在一些中间状态*，接受端接收到RST后不会向对端回复ACK，会立即释放发送、接受缓冲区的数据
    ，然后关闭连接，同样不存在任何中间状态
    *UnpV1,p113,TCP/IP p448*
    <https://www.cnblogs.com/chenny7/p/4708240.html>
    <https://mp.weixin.qq.com/s/p7Wvfp7gJeSSqo7UJIO5ag>

(2)正常通信过程中，服务器处理该套接字的子进程突然终止（被Kill掉）：
   当服务器进程终止时，向客户端发送一个FIN，服务器进入FIN_WAIT1状态，客户端回复ACK，服务端收到ACK后进入FIN_WAIT2状态，客户端进入Close_Wait状态；
   之后，客户端读操作返回0（读到EOF），写操作引发一个RST报文，再次写将引发SIGPIPE信号
   如果读到EOF后，客户端断开连接(用IO复用实现)，会向服务器发送FIN报文，同时客户端进入LAST_WAIT状态，（*注意！，虽然子进程崩溃，但是主机仍在运行，套接字有内核管理，所以可以接受FIN报文*），服务器收到FIN报文后，回复ACK，进入TIME_WAIT状态，客户端收到ACK后，关闭连接


(3)正常通信过程中，主机突然断电：
这种情况下，是不会向客户端发送FIN分节的，客户端无法知道服务器端出现了断电异常，有下面几种处理方式：
1. 应用进程实现了心跳包，即每隔一段时间给对端发送一个短包，如果没有收到响应或者一段时间没有再次收到这个心跳包，则认为对端出现了异常
2. 套接字的SO_KEEPALIVE选项，也是一种心跳包技术（*Unix网络编程卷一：7.5.5节*）；
3. 如果上述两种情况都没有实现，则表现出客户端发送到请求收不到ACK确认，则超时后，客户端重新发送这个请求，一般有一个重传次数限制（有的是重传12次，大约9分钟），当重传次数达到限制后还没有收到ACK，
   客户端将放弃，内核返回给进程一个错误，readline时，直接返回该错误，一般是ETIMEDOUT,也可能中间某个路由器判断处服务器主机不可达，此时返回的是EHOSTUNREAH或者ENETUNCREACH;


(4)正常通信过程中，主机被关机（没有断电）：
UNIT系统上，当关机时，Init进程会给所有进程发送一个SIGTERM信号，这个信号可以被捕捉，用户进程可以捕捉信号，然后执行断开连接的操作，当然也可以忽略该信号或者对该信号捕捉后不做任何处理，     
在发送SIGTERM信号一段固定时间后（一般是5-20秒），init进程会再给所有进程发送一个SIGKILL信号（不能被捕捉的信号），该信号会终止所有进程，如果此时TCP没有断开，则接下来的过程与（2）相同

(5)正常通信过程中，服务器崩溃（断电或者不断电关机），然后立即重启了：
重启之后，服务器端之前的TCP连接就不存在了，此时如果客户端继续发送请求，服务器将回复RST，之后与情况（1）相同；



<https://www.cnblogs.com/jackyangrui/p/7143373.html>


## reset报文
<http://www.javashuo.com/article/p-orqcolwo-gv.html>