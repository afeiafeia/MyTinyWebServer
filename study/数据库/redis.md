##　redis
1. 字符串对象：底层实现：SDS、int、embstr编码的SDS
空间策略
（1）空间预分配
（2）惰性空间释放

编码转换：
元素可以使用long类型表示时，使用int
元素是小于39字节的字符串时，embstr编码的简单动态字符串
元素是大于39字节的字符串时，使用简单动态字符串


2. 列表对象：底层实现：压缩列表或者双端链表
特点：
（1）：双向
（2）无环：头节点的前置节点和尾结点的后置节点指向null
（3）有表头和表尾指针
（4）记录链表长度
（5）多态（*详看redis设计与实现p21*）
编码转换：
当同时满足以下两个条件时使用压缩列表
一是所有的字符串对象都小于64字节
而是元素数量小于512个


3. 哈希对象
底层实现是哈希表或者压缩列表

4. 集合对象
底层实现是整数集合或者哈希表

5. 有序集合对象
底层实现是压缩列表和跳跃表（二者均有）





## 跳跃表
<https://www.cnblogs.com/hunternet/p/11248192.html>
跳跃表的每个节点存在多个指向其它节点的指针，它相当于在链表的基础上添加了多级索引，以提高查找效率，实现快速访问
相当于对一条链表，提取其中若干节点构成一条新链表，得到一新层，以此提取构成多条链表，跳跃表内部节点的多个节点指针即是实现这个多条链表的作用；

内部通过zskiplistNode和zskiplist两个结构组成，前者是跳跃表节点，后者是跳跃表结构，节点中除了存储实际数据外，还有一个层和后退指针，层是一个数组，数组中每一项是一个指向其它节点的指针和到所指节点的跨度；后退指针则是指向他的前一个节点；

zskiplist有四个成员，首尾指针分别指向首尾节点，层数表示节点的最大层数，还有跳跃表的长度表示除首节点之外的节点的数量

跳跃表遍历的时候从最高层到最底层，向尾节点方向遍历

## 整数集合：集合对象的底层实现
用于保存整数值的数据结构，可以保存16位、32位、64位的整数值，并且保证集合中不出现重复值
整数集合使用intset结构表示，内部有三个成员：
(1)保存元素的数组
(2)元素的数量
(3)编码方式：用来指针数组中保存的整数数值的字节长度

## 压缩列表：列表对象和哈希对象的底层实现之一
是由一系列特殊编码的连续内存块组成的顺序型数据结构，压缩列表可以有任意多个节点，每个节点可以保存一个字节数组(保存字符串)或者一个整数值



## 缓存击穿、雪崩、穿透的原因及解决方案
1. 击穿：某些key非常热点，不断受到大量并发访问，当关键字失效后，大量的并发访问直接访问后端数据库，对后端数据库造成过大压力，导致崩溃
   解决方案：对热点数据设置永不过期或者加互斥锁
2. 雪崩：大量key在同一时间段失效，造成该时间段大量的请求直接访问数据库，造成崩溃
   在向redis存数据的时候，失效时间加上一个随机值
3. 穿透：不断访问不存在的数据，由于数据不存在，会访问后端数据库，大量访问将造成数据库崩溃
   使用布隆过滤器，在访问redis之前先通过布隆过滤器判断是否存在



## redis持久化
1. rdb持久化
   原理:通过SAVE命令或者BGSAVE命令生成RDB文件，它是一个压缩的二进制文件，其内保存了执行保存命令时数据库中的键值对数据，服务器启动时，如果没有开启AOF持久化；
   就会载入RDB文件进行持久化；一般不是直接使用SAVE命令，而是提前设置好保存条件，它存储在redisServer结构的saveparms数组中，服务器周期性的执行一个函数，检查保存条件是否有满足的，有则进行rdb文件的创建
2. aof持久化
   原理:通过保存redis执行的写命令来记录数据库状态；
   aof持久化的实现分为命令追加、文件写入和文件同步三个步骤：
   (1)命令追加：当aof持久化功能开启时，对于每一个写操作，服务器在执行完后，会将命令以协议的格式追加至aof_buff缓冲区的末尾；
   (2)文件写入：redis使用时间循环，在每次循环结束之前，会将缓冲区中的命令写入aof文件，实际上是内存上该文件的高速缓存中，根据服务器的配置参数appendfsync不同，同步时机不同;
   如果该值是always，则每次写入都会同步到磁盘；如果是everysec,则每秒进行一次同步（该同步操作有一个专门的线程完成）；如果是no，则每次写入不会进行同步，有操作系统决定合适同步；例如内存紧张时进行内存换出操作
   AOF文件的载入：
   服务器创建一个伪客户端，执行aof文件中的写命令

   上述aof持久化存在的问题：如果只是简单的记录每一条写命令，随着时间流逝，aof文件会越来越大，例如对一个列表对象执行了1000次插入操作，那就要记录1000条写记录；为了解决这个问题，redis提供了aof文件重写功能：
   aof文件重写(BGREWRITEAOF)：从数据库中读取键的值，然后生成一条写命令，一次将该键的所有值写入；
   aof文件重写通过子进程在后台执行：当创建子进程进行aof重写时，服务器会创建一个aof重写缓冲区，它用来记录重写期间服务器执行的写命令；当aof重写工作完成后，将重写缓冲区的命令追加到重写文件，然后用这个aof文件原子地覆盖之前的aof文件
   
区别：
rdb文件保存的是执行持久化时服务库中实际的键值对数据，而aof是保存命令，载入时通过重放命令来持久化



常见问题:
1. AOF、RDB和复制功能对过期键的处理
   (1)当服务器载入RDB文件时：如果服务器以主服务器模式运行，那载入时会对RDB文件中保存的键进行检查，过期键不会载入；
                        如果服务器以从服务器模式运行，载入时将不检查，会将所有键载入，不过之后主从服务器进行同步时，又会清除从服务器之前数据，所以载入过期键也不会有影响
   (2)当服务器正在执行AOF持久化时：如果一个键过期但是还没有被惰性删除或定期删除，AOF文件不做特殊记录，当其被删除之后，会向AOF文件追加一天删除命令，显式删除过期键；
   (3)当服务器通过AOF文件持久化时：对过期键不进行载入；
   (4)主服务器在删除一个过期键后，会向所有从服务器发送删除命令，通知服务器删除过期键，而从服务器在执行客户端发送的读请求时，如果键过期，也不会删除，会当作正常未过期的键进行处理




## 主从复制
 复制功能分为两步：同步+命令传播

 ### 同步
 同步操作要求从服务器向主服务器发送SYNC命令实现；主要步骤是：
 (1):从服务器向主服务器发送SYNC命令
 (2):收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从执行BGSAVE时主服务器所执行的写命令
 (3):RDB文件生成后，主服务器会将其发送给从服务器，从服务器载入RDB文件进行同步，将数据库的状态更新至主服务器执行BGSAVE命令时的状态
 (4):主服务器将缓冲区中的写命令发送给从服务器，从服务器进行重放来实现同步
 ### 命令传播
 执行同步操作之后，主服务器后续会将自己执行的写命令发送给从服务器，来实时保证一致性



 ## 低版本主从复制存在的问题
 短线后重连接情况下，从服务器重新向主服务器发送SYNC命令，将重新进行同步和命令传播，效率低；

 ##　新版本改进
 新版本引入PSYNC命令代替SYNC命令
 PSYNC具有完整重同步和部分重同步两种模式：完整重同步用于初次复制，部分重同步用于断线后重连；
 (1)完整重同步的实现与SYNC命令一致
 (2)部分重同步的实现主要依赖三个因素：
 1. 主服务器的复制偏移量和从服务器的复制偏移量
 2. 主服务器的复制积压缓冲区
 3. 服务器的ID
> *首先是复制偏移量：主服务器上是记录向从服务器发送的字节数，例如发送N个字节，那复制偏移量就增加N;从服务器上是记录接受的字节数，在同步之前，应该进行初始偏移量的同步；这样之后，如果处于一致状态，二者的偏移量需要相等

> *第二是这个复制积压缓冲区，它是主服务器所维护的一个固定长度、先进先出的队列，一般默认大小是1M,当进行命令传播时，主服务器不仅会将所执行的写命令发送给从服务器，还会将发送出去的命令存入复制积压缓冲区，而且这个
>  复制积压缓冲区中记录了每一个字节的对应的复制偏移量，当满了后会将最先放进来的丢弃，这样始终保存了最近所发送的1M数据的副本；当从服务器断线并重新连接上服务器后，向主服务器发送PSYNC命令，同时附上自己的偏移量，
>  主服务器通过对比可以发现这种不一致的问题，然后就判断从服务器复制偏移量所对应的数据在不在复制积压缓冲区，在的话，则把缓冲区中的这些数据发送给从服务器就绪，否则的话，执行完整重同步

>  最后是服务器的ID，服务器在启动的时候会被分配一个ID作为唯一性标识，初次复制时，主服务器会将自己的ID发送给从服务器；
>  当断线后重连接时，从服务器会将自己断线之前所复制的服务器的ID发给主服务器，主服务器对于自己的ID，如果一致，则进行部分重同步操作，否则的话进行完整重同步







   