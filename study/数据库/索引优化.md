## Multi-Range Read(MRR) *InnoDB 存储引擎 5.6.6节*
目的：减少磁盘的随即访问，将随即访问转换为顺序访问
优点：
1. 顺序访问数据：使用辅助索引时，由辅助索引得到聚集索引键，然后对聚集索引键进行排序，按照顺序进行查找
2. 减少缓冲池中页替换次数，如果按照辅助索引的顺序，会大量离散读，可能造成缓冲池频繁更新：例如查询第一个记录读入缓存池，
第二条记录不在缓冲池，此时会更新缓冲池，然后第三条记录与第一条在同一个，又会替换为第一页，增加了替换次数
3. 可以批量处理查询

原理：
通过辅助索引得到对应的主键，然后按照主键排序，之后按照主键的顺序来访问数据。


优化方向：
1. 数据类型优化
2. 创建高性能的索引（什么才算是高性能的索引？）

# 特定类型的优化

## 优化limit分页
*高性能mysql p241* 
<https://mp.weixin.qq.com/s/9XKYvA5hmwictkbd42w-Ug>
使用limit查询时，会查询偏移量+数据量大小的记录，所以，当偏移量很大时，会读取大量的行但是只返回很少一部分，影响效率；
另外，如果查询多个列且索引不是主键，那么每一行都会进行回表查询，这也会降低查询效率
（1）对于读取大量行的问题：可以提前确定好要检索的位置，例如索引是连续且递增的，那么查询1000行开始的10行记录可以改为id>1000的10行记录
（2）对于回表查询：列入下面的语句：
```
SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 1000,10;
//其中id是主键title是普通索引
```
则上面的查询，会先由title查询行记录的主键，然后回表查询行记录，读取1000+10=1010行记录后按照title排序，然后向用户返回前10行
因此这里进行了1010次回表查询
如果改成下面的语句：

```
SELECT film.film_id,film.description FROM sakila.film INNNER JOIN(SELECT film_id FROM sakila.film ORDER BY title LIMIT 1000,10))AS lim USING(film_id)
```
//对于内部的创建的表ELECT film_id FROM sakila.film ORDER BY title LIMIT 1000,10)
会使用覆盖索引扫描提起前1010行的id然后按照title排序并返回10行，外出仅仅对这10行记录的id进行回表查询获取相应的行记录

