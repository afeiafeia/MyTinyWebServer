[TOC]

# 数据库的逻辑结构

![img](https://i.loli.net/2021/03/23/Q9XDiWjmeqNlRAF.png)

- 客户端负责操作连接等前端的输入，
- 下边是server层，server层有
  - 连接器，负责本地或者远程的连接
  - 分析器负责词法分析语法分析，如果是查询的话直接向查询缓存去查找，如果找到了直接返回结果，如果没找到就进入下一步
  - 去优化器去，优化执行语句
  - 执行引擎执行语句，跟存储引擎去读写，返回结果。

# 数据库三大范式

- 第一范式：每个列都不能再拆分
- 第二范式：在第一范式的基础上，非主键完全依赖于主键，而不能是依赖于主键的一部分
- 第三范式：在第二范式的基础上，非主键列表只能依赖于主键，不依赖于其他非主键，

# mysql有关权限的表都有哪几个

- user权限表：记录允许连接到服务器的用户账号信息
- db权限表：记录各个账号在各个数据库上的操作权限
- table_priv权限表：记录数据表级的操作权限
- column_priv：记录数据列级的操作权限
- host权限表：

# mysql的数据类型

## 整数类型

- tinyInt 1个字节
- smallint 2个字节
- mediumint 3个字节
- int 4个字节
- bigint 8个字节

## 浮点数类型

- float 都比bigint大
- double 比bigint大
- decimal

前两个效率比较高

## 字符串类型

- varchar 可变长字符串0-65535
- char 定长 0-255
- text 0-65536字节
- blob 0-65536字节

text和blob类型尽量避免使用，使用的时候消耗会比较严重。

他俩都是0-65536字节大小的长度，但是之所以定义两个类型是因为text保存自负数据，然后blob类型保存二进制类型

## 枚举类型

把不重复的数据存储为一个预定义的集合

## 日期和时间类型

- timestamp
- datetime

# 引擎

引擎是用来实现mysql中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现，常见的存储引擎如下：

- innodb引擎：innodb引擎提供了对数据库acid事务的支持，并且还提供了行级锁和外间的约束
- mylasm引擎：不提供事务的支持，是原本的mysql默认引擎
- memory引擎所有的数据都存储在内存中，数据的处理速度很快，但是安全性不高。

## mylsam于Innodb的区别

### 存储结构

mylasm被存放在三个文件中，frm-表格定义，myd数据文件，myi索引文件

innodb所有的表都被保存在同一个数据文件中

### 存储空间

myslam因为可以被压缩，所以存储空间比较少

innodb仪表需要的内存和存储更多

### 可移植性、备份以及恢复

myslam的数据可以执行比较好

innodb可以通过拷贝数据文件，备份binlog，或者mysqldup的方法来实现，并不方便

### 文件格式

myslam的文件存储中由于是多个文件数据是myd，索引是myi

innodb是集中存储的，都应.idb

### 记录存储顺序

按照记录的插入顺序保存

按照主键大小

### 外健（*MYSQL技术内幕，4.6节*）

myslam不支持

innodb支持

### 事务


myslam不支持

innodb支持

### 锁支持

只支持全文锁，而innodb支持行级锁，表级锁定

### SELECT和Insert Update Delete

myslam是select效率高一点，innodb是insert update和delete的效率比较高

### 索引的实现方式

都是b+树

### 哈希索引与全文索引

myslam支持全文索引，innodb支持hash索引。mylasm是非聚簇索引，而innodb是聚簇索引

### 聚簇索引和非聚簇索引

- 聚簇索引：将数据引擎和索引放到了一块，找到了索引也就找到了数据，因此一个表仅有一个聚簇索引。
- 非聚簇索引：将数据存储和索引分开结构，索引结构的叶子结点指向数据的对应行，然后使用的时候，mylasm会先将索引缓存到内存中，当需要访问数据的时候，在内存中直接搜索索引，然后通过索引直接找到磁盘对应的数据。

## innodb索引的四大特性

- 插入缓冲
- 二次写
- 自适应哈希索引
- 预读

# 什么是索引

索引是一种特殊的文件，就相当于对于数据表的一种目录，为了方便查找的。创建索引的命令：

```mysql
alter table 表格名 add index indexName(字段名)
```

然后是创建唯一索引

``` mysql
alter table table_name add unique [indexName] (username(length))
```

## 索引的优缺点

### 优点：

- 大大加快查询速度
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

### 缺点（索引变多了有什么问题）：

- 时间方面，创建索引和维护索引需要耗费时间，增进行增删改的时候执行效率会降低
- 空间方面，索引需要占用物理空间

## 索引的哪几种类型

### 主键索引

数据列不允许重复，不允许位null，一个表只能有一个主键

### 唯一索引

数据列不允许重复，允许位null，一个表允许多个列创建唯一索引，不允许重复可以这么增加列名

``` mysql
alter table 表明 add unique(column)
```

这样增加一个不允许重复的列名

### 普通索引

基本的索引类型，没有唯一性的限制，允许位NULL值

### 全文索引

## 索引的使用场景

where 的时候

order by的时候

join的时候

## 索引的数据结构

mysql中使用的索引结构多位Hash和B+树的索引，经常使用的innodb的索引结构是B+树，那么需要知道B+树，就要知道B树，B+树的数据结构和原理，然后才能继续探索索引的结构

### B树

B树有些类似平衡二叉树，可以说平衡二叉树是B树的一种变种。b树是平衡的。

![img](https://i.loli.net/2021/03/21/bQJwq3pKC92VSyW.jpg)

类似上图的结构。关于B树，有如下的规则：

1. 排序方式：所有机诶单的关键字是递增顺序，从左到右
2. 子节点的数量：非叶子结点的字节点数量要大于一且小于等于M，这个M就是M插树🌲。例如二叉树的M就是2
3. 关键字数：枝节点的关键字数大于等于 ceil(m/2)-1个且小于等于M-1个，例如M位3，那么非叶子结点的关键字数量要大于1个小雨等于2个。【例如上边的图，叶子结点的数量是3个，不需要满足这个要求】
4. 所有叶子结点都在同一层，不像是二叉树，有层极差的问题，B树所有的叶子结点都在最下面一层。
5. 关键字数：
   1. 每个节点最多有m-1个关键字
   2. 每个节点出了根节点最少有 Math.ceil(m/2)-1个节点
   3. 根节点最少有1个关键字



### B+树
二叉平衡树就好
B+树主要减少IO
B+树跟B树不同的是B+树的非叶子结点不保存关键字记录的指针，只进行数据索引，所有的数据地址必须要到叶子结点才能够获取到，所以每次数据查询的次数都一样。

B+树的叶子几点的关键字从小到大有序排列，左边结尾的数据都会保存右边结点开始数据的指针。

非叶子结点的字节点数 = 关键字数【还有一种说法是B+树的关键字数是叶子结点书-1】

B+树的定义

- 叶子节点个数=关键字数+1
- B+树的内部节点【索引节点】不保存数据只用来索引
- 内部节点最多有m-1个关键字，阶数m同时要求一个叶子结点最多存储m-1个数字
- 叶子芥蒂娜内部是按照从小到大的排列顺序
- 每个叶子结点都有相邻叶子结点的指针。
- 关键字数最小除了跟节点也是math。ceil（m/2）-1个

B+树相对于B树的优势：

- B+树的层级更少，因为非叶子结点存储的关键字的数量更多，所以树的层级更少，叶子结点的数量更多，查询效率更加快
- B+树的查询速度更加稳定
- B+树具有天然的排序功能【叶子结点形成了一个有序的链表】
- B+树全结点的便利更快，因为只需要遍历叶子结点就行

### 为什么使用B+树而不是B树或者是二叉查找树

这个主要是查询效率影响的，如果只是从查询次数来看的话，可能二叉树和B树的查询次数差不多，但是由于树的结点存储在硬盘里边，并且可能他们在硬盘中的地址是不连续的，而由于B树中一个节点可能有多个值，然后取出来的时候都取到内存中，在内存中的比较顺序相比于在硬盘中进行比较对比寻址来说，还是内存中更快一点。

还有一个原因，就是二叉树的层数相比于B树，会差很多，那么相较于B树，可能硬盘读取的次数就比较多。

那么B+树也是一样。因为非叶子结点不存储数据，只存放键，不存放值，索引一次读取就可以在内存也中获取更多的键，然后需要遍历的时候，它本身就是一个链表，而B树却需要遍历树，

## B+树效率更高的原因：<https://mp.weixin.qq.com/s/9XKYvA5hmwictkbd42w-Ug>
对于B树和B+树，首先都存在树节点，它是一个大节点，内部具有多个小节点，小节点上记录了数据，对于B树，数据就是行记录，对于B+树，数据是子节点的指针，因此，相比于B树，B+树的大节点可以存放更多的小节点，MYSQL将每个大节点设置为页面的大小，因此，B+树的大节点可以存放更多的小节点，B+树也就更紧凑，检索时磁盘IO次数也就更小，因此其检索也就更快。
### 为什么不是Hash索引

hash索引就是hash表，进行查找的时候，调用一次hash函数就可以获取响应的key的值，之后u进行回表查询获得实际数据。因此hash索引进行等值查询更快，但是因为hash的索引跟原本的value的顺序并不一致，所以hash索引在底层并不能支持范围查询，遍历也不方便。

在大多数情况下。b+树可以获得稳定并且更好的查询速度，而不需要使用hash索引，因为查询效率不可测，并且出现hash碰撞的时候，查询的效率可能极差。

## 聚集索引和非聚集索引

### 聚集索引

聚集索引就是表数据是按照索引的顺序来存储的，对于聚集索引，叶子结点就存储了真是的数据行。聚集索引其实就是B+树的实现方式，然后值就是真实的值

### 非聚集索引

对于非聚集索引，叶子结点包含索引字段值以及指向那个数据页的数据行的逻辑指针，非聚集索引也是采用了B+树的方式，但是非聚集索引的叶子层并不根实际的数据页相重叠，而是采用叶子层包含一个只想数据页中的指针，如果说这个内部没有聚集索引，那么数据页也就是实际的物理存储很可能会是零散的，例如1在190页的第三行，2就在150页的低1行这样的

# 事务

## 事务的四大特性

- 原子性：最小的执行单位，要么就全部执行，要么语句都没有执行
- 一致性：之前事务前后数据保持一致，多个事务对同一个数据的读取结果是相同的
- 隔离性：并发访问数据库的时候，一个用户的事务不被其他事务锁干扰【有点类似于线程安全】
- 持久性：一个事务被提交之后，它对数据库中的额数据的改变是持久的，

## 什么是脏读，幻读，不可重复读

- 脏读：一个事务更新了数据，同时另外一个事务在读数据，在读数据的过程中另外的那个事务回滚了操作，导致脏读【脏读：一个事务要读取数据，这个事务读取的数据被另外一饿数据更改了但是还没有提交，但是读取的数据是提交后才应该有的，这就是脏读】

![img](https://i.loli.net/2021/03/23/XZyQBJrMj8TsGd6.png)

- 不可重复读：在同一个事务两次用相同的条件读取同一个数据发现结果有差异，就是说在两次读取中，有另外一个事务对数据进行了更改，然后第二次读的是已经更改过后的数据

![img](https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201011603-1317894910.png)

- 幻读：跟不可重复读需要分清楚，不可重复读是数据变了，幻读是多出来几行或者少出来几行：就是说在同一个事务的两次相同的查询中，发现查询的结果返回的行数或者列数变了，这有可能是因为在两次查询中其他事务增加了数据或者增加了属性

![img](https://i.loli.net/2021/03/23/2bl1v6As53ZH9a8.png)



## 如何解决脏读幻读不可重复读-隔离级别

数据库定义了四种不同事务的隔离级别：

- read uncommited: 允许读取尚未提交的数据变更：可能会导致 脏读 不可重复读 幻读
- read commited：只读取提交的数据，可能会导致 不可重复读，幻读
- repeatable read：仍然有可能发生幻读，Innodb解决了幻读
- serilizable：将事务串行华，完全服务acid的隔离级别，所有的事物都依次执行。

mysql默认的是repeatable read 其他的数据库 默认的都是read commited

> SET session TRANSACTION ISOLATION LEVEL Serializable;

## 怎么写事物

``` mysql
savepoint sp1;
begin
rollback sp1
commit
```

## 事务的实现原理

### 原子性实现原理

原子性指的是，事务中的sql语句，要么全部都执行，要么就全部都不执行。

#### 日志

MySQL的日志有很多类型，例如二进制日志，错误日志，查询日志，慢查询日志。此外，还有一些其他的日志，例如事务日志：

- redo log：用来保证持久化的
- undo log：用来保证原子性和隔离性的的基础。

#### 实现原理

undolog是实现原子性的基础。原子性保证事务要么完全执行，要么没有执行。如果执行了一半，发现出现错误，那么就需要进行回滚。当事务对数据库更改数据的时候，innodb会生成一个undolog

undolog是属于记录逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。

以update为例子，undo log应该会记录，操作类型，操作的表的信息，操作的主键的信息，操作的列，操作的列的前后的值。

**在行记录中的undo log**行记录中除了刚才提到的rowid外，还有trx_id和db_roll_ptr, trx_id表示最近修改的事务的id,db_roll_ptr指向undo segment中的undo log。

新增一个事务时事务id会增加，trx_id能够表示事务开始的先后顺序。

Undo log分为Insert和Update两种，delete可以看做是一种特殊的update，即在记录上修改删除标记。

update undo log记录了数据之前的数据信息，通过这些信息可以还原到之前版本的状态。

当进行插入操作时，生成的Insert undo log在事务提交后即可删除，因为其他事务不需要这个undo log。

进行删除修改操作时，会生成对应的undo log，并将当前数据记录中的db_roll_ptr指向新的undo log。

### 持久性实现原理

持久性指的是事务一旦提交，如果对数据库有更改，那么这个更改就是永久的，后续发生什么都不会影响这次事务的。

数据库中的数据都是存放在次盘当中的，但是不可能每次读取都从IO中获取，这样的话，根本满足不了用户希望的速度。

因此，Innodb提供了一个缓存，BufferPool，Buffer Pool中存在一些磁盘中的数据的映射，当用户想要找数据的时候，会首先从Buffer Pool中读取，如果Buffer Pool中没有，那么就从磁盘中先读取到Buffer Pool中。而当想要写数据的时候，就先写入到Buffer Pool中，然后定期从Buffer pool中写入到磁盘中。【刷脏的过程】

以下场景需要考虑：

如果在修改的过程中，修改已经放到了内存中，但是由于突然断电或者系统崩溃，来不及写入到内存当中，那么等下次重启mysql的时候上次更改的内容就会丢失。

于是redo log提出来以解决这些问题，当修改值的时候，不光光是修改buffer_pool的值，也会修改redo log的值。当事务提交的时候，会调用fsync接口对redo log进行刷盘，如果mysql意外退出，重启后mysql会阅读redo log进行数据的恢复。

- redolog采取的策略是wal，就是先写入到redo log 然后才会写入到buffer pool

redolog也是最终保存在磁盘的，但是为什么比从buffer pool写入要快呢？

#### 为什么比bufferpool更快

- 对于数据的修改，是随机的，所以在bufferpool中的修改是随机的，二redo log是追加写入到redo log当中的，所以redolog更快
- bufferpool写入到磁盘当中的时候是以页为单位的，一个数据的修改，需要写入整页到磁盘当中。而redolog只是只是写入需要更改的部分，写入磁盘也是写入追加的部分。

### redolog和binlog

两个log虽然都记录一些数据，用来进行数据的恢复，但是恢复的额目的并不相同

- redolog是用来在mysql宕机或者发生日志之后恢复数据用的，binlog是用来基于时间点的来恢复数据，实现主从复制的一个东西
- redolog是在innodb层，也就是存储引擎实现的，而binlog是server层实现的
- redo log是物理日志，内容基于磁盘的页，而binlog是逻辑日志，他更跟sql语句的关系比较大。

### 隔离性实现原理

隔离性关注的是不同事务之间的不相互影响。那么这个主要关注点在与，我这个事务内部的操作不能影响到其他事物的操作。隔离性的实现主要基于以下几点：

- 【一个事务】的写操作不影响【其他食物的】写操作用的是锁【例如同时只能一个事务对这个数据进行写操作】
- 【一个事务的】写操作不影响【其他事务的】读操作的是mvcc

### 一致性实现原理

一致性是只在满足mysql acid的原子性，持久性，隔离性的基础上，数据首先满足mysql的合法规定，然后复合操作的合理预期，完整性不被破坏。一致性需要多个模块共同配合，需要数据库层面的实现和应用层的实现。

- 保证原子性 持久性 隔离性
- 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
- 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致

## MVCC

### 概述

之前对隔离级别，innodb默认级别是read commited，还有一个级别是 repeateable read级别，这个级别基本上可以解决脏读不可重复读和幻读的问题，但是也有例外情况【会出现幻读的问题】，下图可以很好的看出rr隔离级别的作用，就是相同的查询语句，在不同的事务中存在不同的。

![img](https://i.loli.net/2021/03/23/2hW3mN56t71CrAO.png)

mvcc最大的优点是读不加锁，因此读跟写不会有冲突。实现是主要基于通过以下技术或者数据结构：

- 隐藏列：inoodb中每行数据都有隐藏列，包括事务的id[上一条更新或者插入的事物的id]，指向undo log的指针等等
- 基于undolog的版本链：：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。
- ReadView：【read commit和repeatable read 的区别其实就是生成的readview策略不同】通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据ReadView来确定。 readview就是有一个列表，记录当前活跃着的事务【就是已经begin但是还没有start的事务】，通过这个列表来判断数据库的某个版本跟这个事务是否可见。其中，与可见性相关的属性如下：
  - **up_limit_id**：当前已经提交的事务号 + 1，事务号 < up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。
  - **low_limit_id**：当前最大的事务号 + 1，事务号 >= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。
  - **trx_ids**：为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建RV时，将当前活跃事务ID记录下来，后续即使他们提交对于本事务也是不可见的。

### mvcc的结构和流程

用一张图更好的理解一下：

![img](https://i.loli.net/2021/03/24/n97qNpiCDTBVYSu.jpg)

最后我们来举个例子让我们更好理解上面的内容。

比如我们有如下表：

![img](https://pic3.zhimg.com/80/v2-9fa606c971981ff9986534f957172972_720w.png)

现在有一个事务id是60的执行如下语句并提交：

```mysql
update user set name = '强哥1' where id = 1;
```

此时undo log存在版本链如下：

![img](https://pic3.zhimg.com/80/v2-1bede18add6acd88fbc4fb0c50db2606_720w.jpg)

提交事务id是60的记录后，接着有一个事务id为100的事务，修改name=强哥2，**但是事务还没提交**。则此时的版本链是：

![img](https://pic2.zhimg.com/80/v2-cd43dd12a224c36984bd4c12188a2835_720w.jpg)

**然后在这时，有另外一个事务，发起对id=1的查询**，但是由于此时表中的tri_id为100，没有别的，所以这条记录对其他的事务（也就是此时我们的查询的事务）不可见。但是他会沿着上一版本来查询，发现继续查询下一条，发现trx_id=60的事务号小于up_limit_id，则可见，直接返回结果强哥1。【因为tri_id为100 的时候，还没有提交，所有可能同时的事务的trx_id不大于100，所以这条记录不可见，但是对于已经提交了的事务，那肯定是可见的】

**然后这个时候，提交trx_id=100的事务**，并且新建了一个事务id为110也修改id为1的记录name=强哥3，并且不提交事务。这时候版本链就是：

![img](https://i.loli.net/2021/03/24/uwKyaXrAY7HiUsB.jpg)

**然后那个之前的那个事务，就是读的那个事务，再次发起一个read的时候，如果是readcommited的隔离级别，那么就会有一个新的readview，那活动事务表中的事务id就会发生变化，就可以读到id100的那个强哥二，而如果是rr的隔离级别，那么有可能就不会这样，不会重新readview，也没有新的版本号，也就不会有不可重复读的问题**

也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。

# 锁

## 对mysql的锁了解吗

锁是用来保证并发的，就是并发事务的时候，可能会产生不一样的数据，导致脏读幻读不可重复读等问题，这个时候就需要锁了。

锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

## 隔离级别和锁的关系

隔离界别就是为了解决并发事务而提出来的，其实从根本上就是锁的实现。对于这些隔离级别：

- read uncommited：不加共享锁
- read conmmited：加共享锁，并且在语句执行完成之后释放
- repeatable read：加共享锁，在事务执行完之后释放
- serilizable：锁定整个key，并且一直持有锁，直到事务完成。排他锁

## 按照锁的粒度来划分的话，锁有哪些 锁机制跟innodb的锁算法

- 行级锁：innodb，分为共享锁和排他锁，他是粒度最细的个锁，仅仅对当前操作的行+锁，当然innodb也支持表级锁
- 页级锁：bob：开销一般，但是容易出现死锁
- 表级锁：mylasm：粒度最大的锁，但是容易产生冲突，但是加锁的速度快

## 从锁的类别上来分mysql有哪些锁呢，这些锁定是否会阻碍并发效率

从锁的类别上分别是共享锁和排他锁。

- 共享锁：是一种读锁，当用户要进行数据的读取的时候，对数据加上共享锁，共享锁可以加上多个。

``` mysql
#共享锁
select * 
from table
where 
id=5
lock in share mode
```

- 排他锁：当用户进行数据的写入的时候，加上排他锁，排他锁对共享锁和排他锁都想吃。

``` mysql
#排他锁
select * from 
table
where
 id=5
 for update
```

这两个锁可以避免脏读和不可重复读，但是位了解决幻读，是需要next-key lock，nextkeylock可以避免幻读，是一个种范围锁。

## mysql中的innodb引擎的行锁是怎么实现的

innodb的行锁是根据索引来实现的。如果没有行锁，那么就按照表级锁来使用。

``` mysql
select * from table where xxx for update;
```

这个forupdate就是根据条件来完成行级锁锁定。需要xxx中是的键是索引项

## innodb存储引擎的锁的算法有三种

有三种

- record lock 单个行记录上的锁
- gap lock 间隙锁 锁定一个范围 不包括记录本身
- next-key lock 锁定一个范围，包含记录本身

## 什么是死锁 怎么解决

死锁是指两个或者多个事务上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象，例如两个事务都锁定一个表，然后每个事物都需要对方的那个表做join

### 常见解决死锁的方法：

- 不同程序会并发存取多个表，尽量以互相约定以相同的顺序访问表，就会降低死锁的机会
- 在同一个事物，尽可能一次锁定所需要的资源
- 升级锁的颗粒度，用表级锁

## 数据库的悲观锁和乐观锁是什么 怎么实现的

悲观锁：悲观锁是假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作，在查询完数据的时候就把事务锁起来，一直到提交事务。就是使用数据库中的锁机制

乐观锁：假设不会发生冲突，只是在提交操作的时候检查是否违反数据完整性，在修改数据的时候吧事务锁起来，通过version的方式来进行锁定

# 视图

视图本身是一张虚拟表格，在物理是不存在的，是动态生成的，视图使开发者只关心感兴趣的某些特定数据和特定任务，只能看到视图中定义的数据，对原来表格的安全性提供了安全性

## 视图有哪些特点

视图具有一下特点：

- 视图的列可以来自不同的表，是表的抽象和逻辑意义上建立的新关系，也即是说可以从多张表里边抽象出来建立视图
- 视图是有基本表产生的虚拟的表
- 视图的建立和删除不影响基本表
- 对视图的内容增加，修改和删除会影响基本表
- 当视图来自多个基本表的时候，不允许添加和删除表。

## 视图的使用场景是什么

当使用表的一部分而不是全部的时候，以及当使用表的查询语句经常重复使用的时候，以及需要保护原来表格的数据的时候。

## 视图的优点

- 查询简单，重用查询
- 数据安全
- 逻辑数据独立性

## 视图的缺点

- 效率会降低，因为视图每次使用的时候都是一个查询
- 复杂的视图，例如多个表的视图，不能够增加删除数据，最终还是需要对原来的表格进行变动
- 有unique等集合操作服的视图 有group by子句的视图 有聚合函数的视图 有distinct的视图 连接的视图 【自连接除外】

## 什么是游标

游标是系统为了用户开的一个数据缓冲区，存放SQL语句的执行结果，每个游标都有一个名字。

# 存储过程与函数

存储过程是一个预编译的sql语句，有点事允许模块化的设计，只要创建一次之后，在该程序中就可以调用多次，可以增加效率

### 优点

- 预编译过的，执行效率高
- 存储过程的代码直接存放在数据库中，直接通过名字盗用，减少网络通信
- 安全性高
- 存储过程可以重复使用，减少数据库开发人员的工作量

### 缺点

- 调试麻烦
- 已知问题
- 重新编译问题
- 维护问题

# Savepoint

## 什么是 auto commit

mysql默认采用auto commit自动提交，也就是说 如果没有显式的开启事务，那么就将每一条语句当作事务。

## 关于savepoint

在MySQL中, 保存点SAVEPOINT属于事务控制处理部分。利用SAVEPOINT可以回滚指定部分事务，从而使事务处理更加灵活和精细。SAVEPOINT相关的SQL语句如下

```
SAVEPOINT identifier
```

设置SAVEPOINT。如果重复设置同名savepoint,新的会覆盖老的.

```
RELEASE SAVEPOINT identifier
```

释放SAVEPOINT。

```
ROLLBACK [WORK] TO [SAVEPOINT] identifier
```

回滚到指定的SAVEPOINT。

## 实现

事务中的保存点回滚就跟事务中的rollback一样也是通过 undolog来实现的。

Inoodb在每次修改的时候都会将修改记录在undolog当中，参见函数trx_undo_report_row_operation,每次操作都会记录UNDO日志序号记为undo_no,每次操作undo_no都会递增。回滚只需要反向应用UNDO日志即可。 SAVEPOINT与undo_no是一一对应的。

### 事务中的binlog

事务过程中的操作也是要写入到binlog当中的，现将binlog写入内存，然后等提交的时候再将binlog写入到binlog文件【也就是硬盘】当中**。然而,savepoint回滚时，binlog还在cache中，那么被回滚的那段操作的binlog需要从cache中清理掉。**

至于清理的方法：

- 在事务中设置savepoint的时候，先在内存中记录binlog在内存中的位置
- 然后当回滚的时候，会直接讲这部分内存清理掉。

# 触发器

# mysql主从复制原理

## 什么是主从复制

主从复制是指有一台主服务器，然后有数台从服务器，主服务器中的数据可以自动复制到从服务器当中

## 主从复制的主要用途

### 读写分离

在开发工作的过程中，经常有些SQL语句需要锁表【行锁影响没有表级锁那么大】，造成不能用读服务或者不能其他的写，这样就会影响现有业务，使用主从复制，让主数据库负责写，从数据库负责度，这样即便出现了锁表的情景，也可以读从数据库保证业务的正常运行

### 数据实时备份

当系统中的某个数据库发生故障的时候，可以切换到其他数据库。

### 高可用的架构

随着系统中业务的访问量的增加，如果是单机的数据库，会导致IO访问的频率过高，使用主从复制，就相当于负载均衡了，降低磁盘io的访问频率，提升性能

## 主从复制的实现原理

mysql主从复制涉及到三个线程，一个运行在主节点，其余两个运行子啊从结点：

- 主节点线程：log dump thread
- 从结点线程：io thread sql thread

### 主节点binary log dump线程

当从结点连接主节点时，主节点会创建一个log dump的线程，用于发送binlog的内容，在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成的时候锁被释放

### 从结点io线程

在从节点上执行"start slave"的命令之后，从节点会创建一个io线程用来连接主节点，请求主库中更新bin-log，io线程收到binlog dump线程发来的更新之后，会保存在本地的relay-log当中

### 从结点sql线程

sql线程用来读取relay-log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性

### 详细解释

对于每一个主从链接，都需要三个线程来完成，当主节点有多个从节点的时候，主节点会为每一饿当前的节点的从节点建立一个binary log dump线程，而每个从节点都有自己的io和sql线程。

从节点用两个线程 io和sql线程，分别完成将binlog啦渠道relay log当中，然后sql线程读取relay log解析成语句。这样读取和运行分开的两个线程有一个好处就是，假如这个线程sql没有执行，那么也可以io先读数据，读完保存在relay log当中，当什么时候sql执行都行。

【其实这个过程本质上就是从数据库向主数据库获取操作日志然后根据操作日志的顺序在自己身上完全指从日志中所记录的各种操作】

![img](https://i.loli.net/2021/03/24/1mYobHVIqnPFtUf.jpg)

复制的基本过程如下：

- 从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；
- 主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；
- Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。

### 主从复制的模式

#### 异步模式

异步模式 时mysql主从复制的默认的模式。当从节点连接主节点的时候，会主动向主节点申请bin log文件，这种模式下，主节点不会主动push bin log到从节点，这样有可能从节点没有及时的将最新的bin log同步到本地。

异步模式实际上就是从服务器的申请之后，才会发送

#### 半同步模式

半同步模式不是mysql默认的，需要主节点和从节点安装插件来实现开启半同步模式。

如上图，这种模式下，当主服务写入binlog日志后，就会通知log dump线程发送日志到从服务的I/O线程，等待从服务将日志写入到relay log中，然后返回给主服务一个确认通知，主服务只要接受到一个从服务的确认通知，就会返回给客户端结果，否则需要等待直到超时时间然后切换成异步模式再返回给客户端结果。这样做的目的可以使主从数据库的数据延迟缩小，可以提高数据安全性，确保了事务提交后，binlog至少传输到了一个从节点上，虽然不能保证从节点将此事务更新到db中，但确保了binlog日志已经记录到relay log中。性能上会有一定的降低，客户端响应时间会变长。

#### 同步模式

此中模式就是在半同步的基础上，等待从服务的I/O线程和SQL线程都执行完毕，将数据更新到从服务器后，返回确认信息后，主服务才返回给客户端成功信息。此中模式完全保证了主从服务的数据一致性，但是相应的响应时间会变长，性能较低。

### binlog的记录格式

mysql主从复制有三种方式：

- 基于sql语句的复制 statement based replication
- 基于行的复制 row based replication
- 混合模式复制 mix format  based replication

#### sbr

sbr就是记录sql语句在bin log当中，mysql5.1.4及之前的版本都是使用的这种复制模式

**注：减少了binlog的日志的大小，节约IO 提高性能，缺点是在某些情况下，会导致主从节点中数据不一致**

#### rbr

rbr就是将mysql 的主数据库 将sql语句分解为基于Row更改的语句并且记录在binlog当中，也就是只记录那条数据被修改了，修改成什么样子，有点事不会出现某些特定情况下的存储过程，或者是函数或者是触发器的调用或者出发无法被正确复制的问题，但会产生大量的日志，增加bin log的同步时间，也不能获取到原始的sql执行语句

#### mbr

是以上两种模式的混合，对于一般的复制使用sbr保存到binlog，对于sbr无法复制的操作使用row操作。

### 主从复制的方式

主从复制主要有两种复制方式：

- 传统方式
- GTID方式

#### 传统的主从复制方式

传统方式就是基于binlog日志的postiont点来指定日志从什么位置开始执行增量同步，如果这个位置没有设置对，那么就会出现主从数据不一致的情况

#### GTID主从复制方式

gtid时全局事务id，这个gtid保证了其为每一个在主数据库上提交的事务在从数据库中可以生成一个唯一的id

基于GTID复制实现的工作原理：

- 主节点更新数据时，会在事务前产生gtid,一起记录到binlog当中
- 从节点的IO线程，将发生变化的bin log 记录到从节点本地的relay log当中
- sql线程从relay log获取giid，然后对比本地binlog是否有记录
- 如果有记录，说明该事务已经被执行了
- 如果没有记录，从节点就会从relay log中执行该gtid的事务，然后记录到binlog中

# SQL的执行顺序

在sql的执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。

**执行顺序**

1. from
2. join
3. on
4. where
5. group by
6. avg sum等聚合函数
7. having
8. select
9. distinct
10. order by
11. limit

## 步骤

1. 首先会对from子句中前两个表执行一次笛卡尔积，生成虚拟表vt1
2. 使用on筛选器，on中的逻辑表达式将对vt1中的各个行做个筛选，满足on表达式的生成vt2
3. 如果是outer join会添加外部行，如果是left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。
4. 如果from 中的表还有剩余的，那么就将vt3根这个表进行笛卡尔积，【重复123的过程】
5. where语句，对上一步产生的虚拟表引用where筛选器，生成虚拟表vt4
6. group by子句会将其按照by后边的关键字来组合成一组。得到虚拟表vt5
7. having筛选器。having晒汛期是第一个也是唯一一个应用到已经分组的数据的筛选器
8. 处理select子句，将select中的列筛选出来成vt8
9. 应用distinct子句，移除相同的行
10. 使用order by语句
11. limit语句

# sql调优的几种方式

数据库调优一般分成两种，一个是sql语句的调优，一个是sql执行过程的调优。但是大多数情况指的是sql语句的调优，就是在执行器之前的时候进行优化

## 排除缓存干扰

在我们查看执行效率的时候，会发现原本的sql执行语句就已经很快乐，其实是因为缓存的原因，没有真真的执行，而是命中缓存了，但是如果真正的环境中，会经常发生缓存失效的情况，这是因为对表进行更新的时候，这个表的所有缓存会被删除，所以在实际上线的系统中缓存失效。因为我的版本是mysql5.7的嘛，所以需要在sql优化的explain的时候加上no cached

## Explain

一般使用的时候是

``` sql
explain select * from table
```

### id

id表示查询中执行select子句或者操作表的顺序，id的值越大，代表优先级越高，越先执行。

- 如果id相同，可以理解这三个表为一组，具有相同的优先级，那么执行顺序就由上而下的执行。
- 

## 覆盖索引

## 联合索引

## 最左匹配原则

## 索引下推



# 参考文献

https://zhuanlan.zhihu.com/p/66791480

https://blog.csdn.net/qq_36951116/article/details/108307608

【主从复制】https://zhuanlan.zhihu.com/p/50597960

