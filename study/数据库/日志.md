## redo log（重做日志）
用来实现事务的持久性
当事务提交时，会将事务的所有日志写入重做日志进行持久化，这里是指写入高速缓存（具体何时写入磁盘文件，由相关参数：innodb_flush_log_at_trx_commit参数决定）
每次将重做日志缓冲写入重做日志文件（实际是写入了高速缓存）后，InnoDB存储引擎会自动调用fsync，将其写入磁盘

当然，也可以通过修改参数改变这一行为：
相关参数：innodb_flush_log_at_trx_commit;
默认值为1，执行上述操作，每次提交后执行fsync
如果设置为0，提交时不进行fsync操作，主线程每隔一秒执行一次fsync
如果设置为2，提交时仅仅写入缓存，这种情况下，操作系统的守护进程会周期性的调用sync

为1时，每次提交都要写入磁盘，因此，相比0和2，效率会降低，但保证了事物的持久性，如果设置为0或者2，虽然可以提高事务的性能，但是却使事务丧失了持久性


##　重做日志与二进制日志的区别
1. 重做日志是在InnoDB引擎层产生的，而二进制日志是在MySQL数据库的上层产生的，因此，二进制日志不仅仅针对InnoDB存储引擎，MySQL数据库的任何引擎对于数据库的更改都会产生二进制日志
2. 二进制日志是一种逻辑日志，记录的是对应的SQL语句，而重做日志是物理日志，记录的是对于每个页的修改
3. 两种日志写入（写入页高速缓存）的时间点不同，二进制日志是在事务提交时一次写入，而重做日志是事物执行过程中不断写入

在数据库运行时，不需要对redo log进行读取操作，但undo log则需要随即读取

## undo
与redo存放在日志文件不同，undo存放在数据库内部的一个特殊段中，这个段称为undo段
undo log是将数据库逻辑地恢复到执行前的状态：执行事务的相反操作，并不是将数据库物理地恢复
例如：执行一个Insert 10w条记录的事务，这将导致表空间增大，之后如果rollback，则是执行delete 10w的操作，执行完之后，表空间并不会缩小到执行前的状态
这类似于vector的push_back,例如不断push_back最终导致扩容，之后通过pop_back()将元素弹出（相当于rollback）,但之后容量并不会缩小
另外，undo log是记录了相反的操作，因此，回滚时，会生成redo log

### 作用
undo除了用于回滚外，还用于实现MVCC
